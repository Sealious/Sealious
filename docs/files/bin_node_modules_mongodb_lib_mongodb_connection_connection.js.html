<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bin/node_modules/mongodb/lib/mongodb/connection/connection.js - Prometheus Framework</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Prometheus Framework"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Represents a 
                Replicaset Configuration.html">Represents a 
                Replicaset Configuration</a></li>
                                <li><a href="../classes/Represents a BatchWriteResult.html">Represents a BatchWriteResult</a></li>
                                <li><a href="../classes/Represents a Collection.html">Represents a Collection</a></li>
                                <li><a href="../classes/Represents a Cursor..html">Represents a Cursor.</a></li>
                                <li><a href="../classes/Represents a CursorStream..html">Represents a CursorStream.</a></li>
                                <li><a href="../classes/Represents a Db.html">Represents a Db</a></li>
                                <li><a href="../classes/Represents a GridFS File Stream..html">Represents a GridFS File Stream.</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Represents a MongoClient.html">Represents a MongoClient</a></li>
                                <li><a href="../classes/Represents a Mongos connection with failover to backup proxies.html">Represents a Mongos connection with failover to backup proxies</a></li>
                                <li><a href="../classes/Represents a OrderedBulkOperation.html">Represents a OrderedBulkOperation</a></li>
                                <li><a href="../classes/Represents a Read Preference..html">Represents a Read Preference.</a></li>
                                <li><a href="../classes/Represents a Server connection..html">Represents a Server connection.</a></li>
                                <li><a href="../classes/Represents a UnorderedBulkOperation.html">Represents a UnorderedBulkOperation</a></li>
                                <li><a href="../classes/Represents the Admin methods of MongoDB..html">Represents the Admin methods of MongoDB.</a></li>
                                <li><a href="../classes/Represents the Grid..html">Represents the Grid.</a></li>
                                <li><a href="../classes/Represents the GridStore..html">Represents the GridStore.</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/association.html">association</a></li>
                                <li><a href="../modules/database-accessor.html">database-accessor</a></li>
                                <li><a href="../modules/field-type-manager.html">field-type-manager</a></li>
                                <li><a href="../modules/resource-type-manager.html">resource-type-manager</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: bin/node_modules/mongodb/lib/mongodb/connection/connection.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        var utils = require(&#x27;./connection_utils&#x27;),
                          inherits = require(&#x27;util&#x27;).inherits,
                          net = require(&#x27;net&#x27;),
                          EventEmitter = require(&#x27;events&#x27;).EventEmitter,
                          inherits = require(&#x27;util&#x27;).inherits,
                          binaryutils = require(&#x27;../utils&#x27;),
                          tls = require(&#x27;tls&#x27;);
                        
                        var Connection = exports.Connection = function(id, socketOptions) {
                          var self = this;
                          // Set up event emitter
                          EventEmitter.call(this);
                          // Store all socket options
                          this.socketOptions = socketOptions ? socketOptions : {host:&#x27;localhost&#x27;, port:27017, domainSocket:false};
                          // Set keep alive default if not overriden
                          if(this.socketOptions.keepAlive == null &amp;&amp; (process.platform !== &quot;sunos&quot; || process.platform !== &quot;win32&quot;)) this.socketOptions.keepAlive = 100;
                          // Id for the connection
                          this.id = id;
                          // State of the connection
                          this.connected = false;
                          // Set if this is a domain socket
                          this.domainSocket = this.socketOptions.domainSocket;
                        
                          // Supported min and max wire protocol
                          this.minWireVersion = 0;
                          this.maxWireVersion = 2;
                        
                          //
                          // Connection parsing state
                          //
                          this.maxBsonSize = socketOptions.maxBsonSize ? socketOptions.maxBsonSize : Connection.DEFAULT_MAX_BSON_SIZE;
                          this.maxMessageSizeBytes = socketOptions.maxMessageSizeBytes ? socketOptions.maxMessageSizeBytes : Connection.DEFAULT_MAX_MESSAGE_SIZE;
                          this.maxNumberOfDocsInBatch = socketOptions.maxWriteBatchSize ? socketOptions.maxWriteBatchSize : Connection.DEFAULT_MAX_WRITE_BATCH_SIZE;
                          // Contains the current message bytes
                          this.buffer = null;
                          // Contains the current message size
                          this.sizeOfMessage = 0;
                          // Contains the readIndex for the messaage
                          this.bytesRead = 0;
                          // Contains spill over bytes from additional messages
                          this.stubBuffer = 0;
                        
                          // Just keeps list of events we allow
                          this.eventHandlers = {error:[], parseError:[], poolReady:[], message:[], close:[], timeout:[], end:[]};
                        
                          // Just keeps list of events we allow
                          resetHandlers(this, false);
                          
                          // Bson object
                          this.maxBsonSettings = {
                              disableDriverBSONSizeCheck: this.socketOptions[&#x27;disableDriverBSONSizeCheck&#x27;] || false
                            , maxBsonSize: this.maxBsonSize
                            , maxMessageSizeBytes: this.maxMessageSizeBytes
                          }
                        
                          // Allow setting the socketTimeoutMS on all connections
                          // to work around issues such as secondaries blocking due to compaction
                          Object.defineProperty(this, &quot;socketTimeoutMS&quot;, {
                              enumerable: true
                            , get: function () { return self.socketOptions.socketTimeoutMS; }
                            , set: function (value) { 
                              // Set the socket timeoutMS value
                              self.socketOptions.socketTimeoutMS = value;
                              // Set the physical connection timeout
                              self.connection.setTimeout(self.socketOptions.socketTimeoutMS);
                            }
                          });  
                        }
                        
                        // Set max bson size
                        Connection.DEFAULT_MAX_BSON_SIZE = 1024 * 1024 * 4;
                        // Set default to max bson to avoid overflow or bad guesses
                        Connection.DEFAULT_MAX_MESSAGE_SIZE = Connection.DEFAULT_MAX_BSON_SIZE;
                        // Max default write bulk ops
                        Connection.DEFAULT_MAX_WRITE_BATCH_SIZE = 2000;
                        
                        // Inherit event emitter so we can emit stuff wohoo
                        inherits(Connection, EventEmitter);
                        
                        Connection.prototype.start = function() {
                          var self = this;
                        
                          // If we have a normal connection
                          if(this.socketOptions.ssl) {
                            // Create new connection instance
                            if(this.domainSocket) {
                              this.connection = net.createConnection(this.socketOptions.host);
                            } else {
                              this.connection = net.createConnection(this.socketOptions.port, this.socketOptions.host);
                            }
                            if(this.logger != null &amp;&amp; this.logger.doDebug){
                              this.logger.debug(&quot;opened connection&quot;, this.socketOptions);
                            }
                        
                            // Set options on the socket
                            this.connection.setTimeout(this.socketOptions.connectTimeoutMS != null ? this.socketOptions.connectTimeoutMS : this.socketOptions.timeout);
                            // Work around for 0.4.X
                            if(process.version.indexOf(&quot;v0.4&quot;) == -1) this.connection.setNoDelay(this.socketOptions.noDelay);
                            // Set keep alive if defined
                            if(process.version.indexOf(&quot;v0.4&quot;) == -1) {
                              if(this.socketOptions.keepAlive &gt; 0) {
                                this.connection.setKeepAlive(true, this.socketOptions.keepAlive);
                              } else {
                                this.connection.setKeepAlive(false);
                              }
                            }
                        
                            // Check if the driver should validate the certificate
                            var validate_certificates = this.socketOptions.sslValidate == true ? true : false;
                        
                            // Create options for the tls connection
                            var tls_options = {
                                socket: this.connection
                              , rejectUnauthorized: false
                            }
                        
                            // If we wish to validate the certificate we have provided a ca store
                            if(validate_certificates) {
                              tls_options.ca = this.socketOptions.sslCA;
                            }
                        
                            // If we have a certificate to present
                            if(this.socketOptions.sslCert) {      
                              tls_options.cert = this.socketOptions.sslCert;
                              tls_options.key = this.socketOptions.sslKey;
                            }
                        
                            // If the driver has been provided a private key password
                            if(this.socketOptions.sslPass) {
                              tls_options.passphrase = this.socketOptions.sslPass;
                            }
                        
                            // Contains the cleartext stream
                            var cleartext = null;
                            // Attempt to establish a TLS connection to the server
                            try {
                              cleartext = tls.connect(this.socketOptions.port, this.socketOptions.host, tls_options, function() {      
                                // If we have a ssl certificate validation error return an error
                                if(cleartext.authorizationError &amp;&amp; validate_certificates) {          
                                  // Emit an error
                                  return self.emit(&quot;error&quot;, cleartext.authorizationError, self, {ssl:true});        
                                }
                                
                                // Connect to the server
                                connectHandler(self)();
                              })      
                            } catch(err) {
                              return self.emit(&quot;error&quot;, &quot;SSL connection failed&quot;, self, {ssl:true});
                            }
                        
                            // Save the output stream
                            this.writeSteam = cleartext;
                        
                            // Set up data handler for the clear stream
                            cleartext.on(&quot;data&quot;, createDataHandler(this));
                            // Do any handling of end event of the stream
                            cleartext.on(&quot;end&quot;, endHandler(this));
                            cleartext.on(&quot;error&quot;, errorHandler(this));    
                        
                            // Handle any errors
                            this.connection.on(&quot;error&quot;, errorHandler(this));    
                            // Handle timeout
                            this.connection.on(&quot;timeout&quot;, timeoutHandler(this));
                            // Handle drain event
                            this.connection.on(&quot;drain&quot;, drainHandler(this));
                            // Handle the close event
                            this.connection.on(&quot;close&quot;, closeHandler(this));
                          } else {
                            // Create new connection instance
                            if(this.domainSocket) {
                              this.connection = net.createConnection(this.socketOptions.host);
                            } else {
                              this.connection = net.createConnection(this.socketOptions.port, this.socketOptions.host);
                            }
                            if(this.logger != null &amp;&amp; this.logger.doDebug){
                              this.logger.debug(&quot;opened connection&quot;, this.socketOptions);
                            }
                        
                            // Set options on the socket
                            this.connection.setTimeout(this.socketOptions.connectTimeoutMS != null ? this.socketOptions.connectTimeoutMS : this.socketOptions.timeout);
                            // Work around for 0.4.X
                            if(process.version.indexOf(&quot;v0.4&quot;) == -1) this.connection.setNoDelay(this.socketOptions.noDelay);
                            // Set keep alive if defined
                            if(process.version.indexOf(&quot;v0.4&quot;) == -1) {
                              if(this.socketOptions.keepAlive &gt; 0) {
                                this.connection.setKeepAlive(true, this.socketOptions.keepAlive);
                              } else {
                                this.connection.setKeepAlive(false);
                              }
                            }
                        
                            // Set up write stream
                            this.writeSteam = this.connection;
                            // Add handlers
                            this.connection.on(&quot;error&quot;, errorHandler(this));
                            // Add all handlers to the socket to manage it
                            this.connection.on(&quot;connect&quot;, connectHandler(this));
                            // this.connection.on(&quot;end&quot;, endHandler(this));
                            this.connection.on(&quot;data&quot;, createDataHandler(this));
                            this.connection.on(&quot;timeout&quot;, timeoutHandler(this));
                            this.connection.on(&quot;drain&quot;, drainHandler(this));
                            this.connection.on(&quot;close&quot;, closeHandler(this));
                          }
                        }
                        
                        /**
                         * @ignore
                         */
                        Connection.prototype.setSocketOptions = function(options) {
                          options = options || {};
                        
                          if(typeof options.connectTimeoutMS == &#x27;number&#x27;) {
                            this.socketOptions.connectTimeoutMS = options.connectTimeoutMS;
                          }
                        
                          if(typeof options.socketTimeoutMS == &#x27;number&#x27;) {
                            this.socketOptions.socketTimeoutMS = options.socketTimeoutMS;
                            // Set the current socket timeout
                            this.connection.setTimeout(options.socketTimeoutMS);
                          }
                        }
                        
                        // Check if the sockets are live
                        Connection.prototype.isConnected = function() {
                          return this.connected &amp;&amp; !this.connection.destroyed &amp;&amp; this.connection.writable;
                        }
                        
                        // Validate if the driver supports this server
                        Connection.prototype.isCompatible = function() {
                          if(this.serverCapabilities == null) return true;
                          // Is compatible with backward server
                          if(this.serverCapabilities.minWireVersion == 0 
                            &amp;&amp; this.serverCapabilities.maxWireVersion ==0) return true;
                        
                          // Check if we overlap
                          if(this.serverCapabilities.minWireVersion &gt;= this.minWireVersion
                            &amp;&amp; this.serverCapabilities.maxWireVersion &lt;= this.maxWireVersion) return true;
                        
                          // Not compatible
                          return false;
                        }
                        
                        // Write the data out to the socket
                        Connection.prototype.write = function(command, callback) {
                          try {
                            // If we have a list off commands to be executed on the same socket
                            if(Array.isArray(command)) {
                              for(var i = 0; i &lt; command.length; i++) {
                                try {
                                  // Pass in the bson validation settings (validate early)
                                  var binaryCommand = command[i].toBinary(this.maxBsonSettings);
                        
                                  if(this.logger != null &amp;&amp; this.logger.doDebug) 
                                    this.logger.debug(&quot;writing command to mongodb&quot;, {binary: binaryCommand, json: command[i]});
                        
                                  this.writeSteam.write(binaryCommand);
                                } catch(err) {
                                  return callback(err, null);
                                }
                              }
                            } else {
                              try {
                                // Pass in the bson validation settings (validate early)
                                var binaryCommand = command.toBinary(this.maxBsonSettings);
                                // Do we have a logger active log the event
                                if(this.logger != null &amp;&amp; this.logger.doDebug) 
                                  this.logger.debug(&quot;writing command to mongodb&quot;, {binary: binaryCommand, json: command});
                                // Write the binary command out to socket
                                this.writeSteam.write(binaryCommand);
                              } catch(err) {
                                return callback(err, null);
                              }
                            }
                          } catch (err) {
                            if(typeof callback === &#x27;function&#x27;) callback(err);
                          }
                        }
                        
                        // Force the closure of the connection
                        Connection.prototype.close = function() {
                          // clear out all the listeners
                          resetHandlers(this, true);
                          // Add a dummy error listener to catch any weird last moment errors (and ignore them)
                          this.connection.on(&quot;error&quot;, function() {})
                          // destroy connection
                          this.connection.destroy();
                          if(this.logger != null &amp;&amp; this.logger.doDebug){
                            this.logger.debug(&quot;closed connection&quot;, this.connection);
                          }
                        }
                        
                        // Reset all handlers
                        var resetHandlers = function(self, clearListeners) {
                          self.eventHandlers = {error:[], connect:[], close:[], end:[], timeout:[], parseError:[], message:[]};
                        
                          // If we want to clear all the listeners
                          if(clearListeners &amp;&amp; self.connection != null) {
                            var keys = Object.keys(self.eventHandlers);
                            // Remove all listeners
                            for(var i = 0; i &lt; keys.length; i++) {
                              self.connection.removeAllListeners(keys[i]);
                            }
                          }
                        }
                        
                        //
                        // Handlers
                        //
                        
                        // Connect handler
                        var connectHandler = function(self) {
                          return function(data) {
                            // Set connected
                            self.connected = true;
                            // Now that we are connected set the socket timeout
                            self.connection.setTimeout(self.socketOptions.socketTimeoutMS != null ? self.socketOptions.socketTimeoutMS : self.socketOptions.timeout);
                            // Emit the connect event with no error
                            self.emit(&quot;connect&quot;, null, self);
                          }
                        }
                        
                        var createDataHandler = exports.Connection.createDataHandler = function(self) {
                          // We need to handle the parsing of the data
                          // and emit the messages when there is a complete one
                          return function(data) {
                            // Parse until we are done with the data
                            while(data.length &gt; 0) {
                              // If we still have bytes to read on the current message
                              if(self.bytesRead &gt; 0 &amp;&amp; self.sizeOfMessage &gt; 0) {
                                // Calculate the amount of remaining bytes
                                var remainingBytesToRead = self.sizeOfMessage - self.bytesRead;
                                // Check if the current chunk contains the rest of the message
                                if(remainingBytesToRead &gt; data.length) {
                                  // Copy the new data into the exiting buffer (should have been allocated when we know the message size)
                                  data.copy(self.buffer, self.bytesRead);
                                  // Adjust the number of bytes read so it point to the correct index in the buffer
                                  self.bytesRead = self.bytesRead + data.length;
                        
                                  // Reset state of buffer
                                  data = new Buffer(0);
                                } else {
                                  // Copy the missing part of the data into our current buffer
                                  data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead);
                                  // Slice the overflow into a new buffer that we will then re-parse
                                  data = data.slice(remainingBytesToRead);
                        
                                  // Emit current complete message
                                  try {
                                    var emitBuffer = self.buffer;
                                    // Reset state of buffer
                                    self.buffer = null;
                                    self.sizeOfMessage = 0;
                                    self.bytesRead = 0;
                                    self.stubBuffer = null;
                                    // Emit the buffer
                                    self.emit(&quot;message&quot;, emitBuffer, self);
                                  } catch(err) {
                                    var errorObject = {err:&quot;socketHandler&quot;, trace:err, bin:self.buffer, parseState:{
                                      sizeOfMessage:self.sizeOfMessage,
                                      bytesRead:self.bytesRead,
                                      stubBuffer:self.stubBuffer}};
                                    if(self.logger != null &amp;&amp; self.logger.doError) self.logger.error(&quot;parseError&quot;, errorObject);
                                    // We got a parse Error fire it off then keep going
                                    self.emit(&quot;parseError&quot;, errorObject, self);
                                  }
                                }
                              } else {
                                // Stub buffer is kept in case we don&#x27;t get enough bytes to determine the
                                // size of the message (&lt; 4 bytes)
                                if(self.stubBuffer != null &amp;&amp; self.stubBuffer.length &gt; 0) {
                        
                                  // If we have enough bytes to determine the message size let&#x27;s do it
                                  if(self.stubBuffer.length + data.length &gt; 4) {
                                    // Prepad the data
                                    var newData = new Buffer(self.stubBuffer.length + data.length);
                                    self.stubBuffer.copy(newData, 0);
                                    data.copy(newData, self.stubBuffer.length);
                                    // Reassign for parsing
                                    data = newData;
                        
                                    // Reset state of buffer
                                    self.buffer = null;
                                    self.sizeOfMessage = 0;
                                    self.bytesRead = 0;
                                    self.stubBuffer = null;
                        
                                  } else {
                        
                                    // Add the the bytes to the stub buffer
                                    var newStubBuffer = new Buffer(self.stubBuffer.length + data.length);
                                    // Copy existing stub buffer
                                    self.stubBuffer.copy(newStubBuffer, 0);
                                    // Copy missing part of the data
                                    data.copy(newStubBuffer, self.stubBuffer.length);
                                    // Exit parsing loop
                                    data = new Buffer(0);
                                  }
                                } else {
                                  if(data.length &gt; 4) {
                                    // Retrieve the message size
                                    var sizeOfMessage = binaryutils.decodeUInt32(data, 0);
                                    // If we have a negative sizeOfMessage emit error and return
                                    if(sizeOfMessage &lt; 0 || sizeOfMessage &gt; self.maxMessageSizeBytes) {
                                      var errorObject = {err:&quot;socketHandler&quot;, trace:&#x27;&#x27;, bin:self.buffer, parseState:{
                                        sizeOfMessage: sizeOfMessage,
                                        bytesRead: self.bytesRead,
                                        stubBuffer: self.stubBuffer}};
                                      if(self.logger != null &amp;&amp; self.logger.doError) self.logger.error(&quot;parseError&quot;, errorObject);
                                      // We got a parse Error fire it off then keep going
                                      self.emit(&quot;parseError&quot;, errorObject, self);
                                      return;
                                    }
                        
                                    // Ensure that the size of message is larger than 0 and less than the max allowed
                                    if(sizeOfMessage &gt; 4 &amp;&amp; sizeOfMessage &lt; self.maxBsonSize &amp;&amp; sizeOfMessage &gt; data.length) {
                                      self.buffer = new Buffer(sizeOfMessage);
                                      // Copy all the data into the buffer
                                      data.copy(self.buffer, 0);
                                      // Update bytes read
                                      self.bytesRead = data.length;
                                      // Update sizeOfMessage
                                      self.sizeOfMessage = sizeOfMessage;
                                      // Ensure stub buffer is null
                                      self.stubBuffer = null;
                                      // Exit parsing loop
                                      data = new Buffer(0);
                        
                                    } else if(sizeOfMessage &gt; 4 &amp;&amp; sizeOfMessage &lt; self.maxBsonSize &amp;&amp; sizeOfMessage == data.length) {
                                      try {
                                        var emitBuffer = data;
                                        // Reset state of buffer
                                        self.buffer = null;
                                        self.sizeOfMessage = 0;
                                        self.bytesRead = 0;
                                        self.stubBuffer = null;
                                        // Exit parsing loop
                                        data = new Buffer(0);
                                        // Emit the message
                                        self.emit(&quot;message&quot;, emitBuffer, self);
                                      } catch (err) {
                                        var errorObject = {err:&quot;socketHandler&quot;, trace:err, bin:self.buffer, parseState:{
                                          sizeOfMessage:self.sizeOfMessage,
                                          bytesRead:self.bytesRead,
                                          stubBuffer:self.stubBuffer}};
                                        if(self.logger != null &amp;&amp; self.logger.doError) self.logger.error(&quot;parseError&quot;, errorObject);
                                        // We got a parse Error fire it off then keep going
                                        self.emit(&quot;parseError&quot;, errorObject, self);
                                      }
                                    } else if(sizeOfMessage &lt;= 4 || sizeOfMessage &gt; self.maxBsonSize) {
                                      var errorObject = {err:&quot;socketHandler&quot;, trace:null, bin:data, parseState:{
                                        sizeOfMessage:sizeOfMessage,
                                        bytesRead:0,
                                        buffer:null,
                                        stubBuffer:null}};
                                      if(self.logger != null &amp;&amp; self.logger.doError) self.logger.error(&quot;parseError&quot;, errorObject);
                                      // We got a parse Error fire it off then keep going
                                      self.emit(&quot;parseError&quot;, errorObject, self);
                        
                                      // Clear out the state of the parser
                                      self.buffer = null;
                                      self.sizeOfMessage = 0;
                                      self.bytesRead = 0;
                                      self.stubBuffer = null;
                                      // Exit parsing loop
                                      data = new Buffer(0);
                        
                                    } else {
                                      try {
                                        var emitBuffer = data.slice(0, sizeOfMessage);
                                        // Reset state of buffer
                                        self.buffer = null;
                                        self.sizeOfMessage = 0;
                                        self.bytesRead = 0;
                                        self.stubBuffer = null;
                                        // Copy rest of message
                                        data = data.slice(sizeOfMessage);
                                        // Emit the message
                                        self.emit(&quot;message&quot;, emitBuffer, self);
                                      } catch (err) {
                                        var errorObject = {err:&quot;socketHandler&quot;, trace:err, bin:self.buffer, parseState:{
                                          sizeOfMessage:sizeOfMessage,
                                          bytesRead:self.bytesRead,
                                          stubBuffer:self.stubBuffer}};
                                        if(self.logger != null &amp;&amp; self.logger.doError) self.logger.error(&quot;parseError&quot;, errorObject);
                                        // We got a parse Error fire it off then keep going
                                        self.emit(&quot;parseError&quot;, errorObject, self);
                                      }
                        
                                    }
                                  } else {
                                    // Create a buffer that contains the space for the non-complete message
                                    self.stubBuffer = new Buffer(data.length)
                                    // Copy the data to the stub buffer
                                    data.copy(self.stubBuffer, 0);
                                    // Exit parsing loop
                                    data = new Buffer(0);
                                  }
                                }
                              }
                            }
                          }
                        }
                        
                        var endHandler = function(self) {
                          return function() {
                            // Set connected to false
                            self.connected = false;
                            // Emit end event
                            self.emit(&quot;end&quot;, {err: &#x27;connection received Fin packet from [&#x27; + self.socketOptions.host + &#x27;:&#x27; + self.socketOptions.port + &#x27;]&#x27;}, self);
                          }
                        }
                        
                        var timeoutHandler = function(self) {
                          return function() {
                            // Set connected to false
                            self.connected = false;
                            // Emit timeout event
                            self.emit(&quot;timeout&quot;, {err: &#x27;connection to [&#x27; + self.socketOptions.host + &#x27;:&#x27; + self.socketOptions.port + &#x27;] timed out&#x27;}, self);
                          }
                        }
                        
                        var drainHandler = function(self) {
                          return function() {
                          }
                        }
                        
                        var errorHandler = function(self) {
                          return function(err) {
                            self.connection.destroy();
                            // Set connected to false
                            self.connected = false;
                            // Emit error
                            self.emit(&quot;error&quot;, {err: &#x27;failed to connect to [&#x27; + self.socketOptions.host + &#x27;:&#x27; + self.socketOptions.port + &#x27;]&#x27;}, self);
                          }
                        }
                        
                        var closeHandler = function(self) {
                          return function(hadError) {
                            // If we have an error during the connection phase
                            if(hadError &amp;&amp; !self.connected) {
                              // Set disconnected
                              self.connected = false;
                              // Emit error
                              self.emit(&quot;error&quot;, {err: &#x27;failed to connect to [&#x27; + self.socketOptions.host + &#x27;:&#x27; + self.socketOptions.port + &#x27;]&#x27;}, self);
                            } else {
                              // Set disconnected
                              self.connected = false;
                              // Emit close
                              self.emit(&quot;close&quot;, {err: &#x27;connection closed to [&#x27; + self.socketOptions.host + &#x27;:&#x27; + self.socketOptions.port + &#x27;]&#x27;}, self);
                            }
                          }
                        }
                        
                        // Some basic defaults
                        Connection.DEFAULT_PORT = 27017;
                        
                        
                        
                        
                        
                        
                        
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
