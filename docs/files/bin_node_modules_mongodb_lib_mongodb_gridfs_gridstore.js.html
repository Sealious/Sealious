<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bin/node_modules/mongodb/lib/mongodb/gridfs/gridstore.js - Prometheus Framework</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Prometheus Framework"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Represents a 
                Replicaset Configuration.html">Represents a 
                Replicaset Configuration</a></li>
                                <li><a href="../classes/Represents a BatchWriteResult.html">Represents a BatchWriteResult</a></li>
                                <li><a href="../classes/Represents a Collection.html">Represents a Collection</a></li>
                                <li><a href="../classes/Represents a Cursor..html">Represents a Cursor.</a></li>
                                <li><a href="../classes/Represents a CursorStream..html">Represents a CursorStream.</a></li>
                                <li><a href="../classes/Represents a Db.html">Represents a Db</a></li>
                                <li><a href="../classes/Represents a GridFS File Stream..html">Represents a GridFS File Stream.</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Represents a MongoClient.html">Represents a MongoClient</a></li>
                                <li><a href="../classes/Represents a Mongos connection with failover to backup proxies.html">Represents a Mongos connection with failover to backup proxies</a></li>
                                <li><a href="../classes/Represents a OrderedBulkOperation.html">Represents a OrderedBulkOperation</a></li>
                                <li><a href="../classes/Represents a Read Preference..html">Represents a Read Preference.</a></li>
                                <li><a href="../classes/Represents a Server connection..html">Represents a Server connection.</a></li>
                                <li><a href="../classes/Represents a UnorderedBulkOperation.html">Represents a UnorderedBulkOperation</a></li>
                                <li><a href="../classes/Represents the Admin methods of MongoDB..html">Represents the Admin methods of MongoDB.</a></li>
                                <li><a href="../classes/Represents the Grid..html">Represents the Grid.</a></li>
                                <li><a href="../classes/Represents the GridStore..html">Represents the GridStore.</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/association.html">association</a></li>
                                <li><a href="../modules/database-accessor.html">database-accessor</a></li>
                                <li><a href="../modules/field-type-manager.html">field-type-manager</a></li>
                                <li><a href="../modules/resource-type-manager.html">resource-type-manager</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: bin/node_modules/mongodb/lib/mongodb/gridfs/gridstore.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /**
                         * @fileOverview GridFS is a tool for MongoDB to store files to the database.
                         * Because of the restrictions of the object size the database can hold, a
                         * facility to split a file into several chunks is needed. The {@link GridStore}
                         * class offers a simplified api to interact with files while managing the
                         * chunks of split files behind the scenes. More information about GridFS can be
                         * found &lt;a href=&quot;http://www.mongodb.org/display/DOCS/GridFS&quot;&gt;here&lt;/a&gt;.
                         */
                        var Chunk = require(&#x27;./chunk&#x27;).Chunk,
                          DbCommand = require(&#x27;../commands/db_command&#x27;).DbCommand,
                          ObjectID = require(&#x27;bson&#x27;).ObjectID,
                          Buffer = require(&#x27;buffer&#x27;).Buffer,
                          fs = require(&#x27;fs&#x27;),
                          timers = require(&#x27;timers&#x27;),
                          util = require(&#x27;util&#x27;),
                          inherits = util.inherits,
                          ReadStream = require(&#x27;./readstream&#x27;).ReadStream,
                          Stream = require(&#x27;stream&#x27;);
                        
                        // Set processor, setImmediate if 0.10 otherwise nextTick
                        var processor = require(&#x27;../utils&#x27;).processor();
                        
                        var REFERENCE_BY_FILENAME = 0,
                          REFERENCE_BY_ID = 1;
                        
                        /**
                         * A class representation of a file stored in GridFS.
                         *
                         * Modes
                         *  - **&quot;r&quot;** - read only. This is the default mode.
                         *  - **&quot;w&quot;** - write in truncate mode. Existing data will be overwriten.
                         *  - **w+&quot;** - write in edit mode (append is not guaranteed for concurrent operations)
                         *
                         * Options
                         *  - **root** {String}, root collection to use. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
                         *  - **content_type** {String}, mime type of the file. Defaults to **{GridStore.DEFAULT_CONTENT_TYPE}**.
                         *  - **chunk_size** {Number}, size for the chunk. Defaults to **{Chunk.DEFAULT_CHUNK_SIZE}**.
                         *  - **metadata** {Object}, arbitrary data the user wants to store.
                         *  - **readPreference** {String}, the prefered read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
                         *  - **w**, {Number/String, &gt; -1 || &#x27;majority&#x27; || tag name} the write concern for the operation where &lt; 1 is no acknowlegement of write and w &gt;= 1, w = &#x27;majority&#x27; or tag acknowledges the write
                         *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)
                         *  - **fsync**, (Boolean, default:false) write waits for fsync before returning, from MongoDB 2.6 on, fsync cannot be combined with journal
                         *  - **j**, (Boolean, default:false) write waits for journal sync before returning
                         *
                         * @class Represents the GridStore.
                         * @param {Db} db A database instance to interact with.
                         * @param {Any} [id] optional unique id for this file
                         * @param {String} [filename] optional filename for this file, no unique constrain on the field
                         * @param {String} mode set the mode for this file.
                         * @param {Object} options optional properties to specify.
                         * @return {GridStore}
                         */
                        var GridStore = function GridStore(db, id, filename, mode, options) {
                          if(!(this instanceof GridStore)) return new GridStore(db, id, filename, mode, options);
                        
                          var self = this;
                          this.db = db;
                        
                          // Call stream constructor
                          if(typeof Stream == &#x27;function&#x27;) {
                            Stream.call(this);
                          }
                        
                          // Handle options
                          if(typeof options === &#x27;undefined&#x27;) options = {};
                          // Handle mode
                          if(typeof mode === &#x27;undefined&#x27;) {
                            mode = filename;
                            filename = undefined;
                          } else if(typeof mode == &#x27;object&#x27;) {
                            options = mode;
                            mode = filename;
                            filename = undefined;
                          }
                        
                          if(id instanceof ObjectID) {
                            this.referenceBy = REFERENCE_BY_ID;
                            this.fileId = id;
                            this.filename = filename;
                          } else if(typeof filename == &#x27;undefined&#x27;) {
                            this.referenceBy = REFERENCE_BY_FILENAME;
                            this.filename = id;
                            if (mode.indexOf(&#x27;w&#x27;) != null) {
                              this.fileId = new ObjectID();
                            }
                          } else {
                            this.referenceBy = REFERENCE_BY_ID;
                            this.fileId = id;
                            this.filename = filename;
                          }
                        
                          // Set up the rest
                          this.mode = mode == null ? &quot;r&quot; : mode;
                          this.options = options || {};
                        
                          // Set the root if overridden
                          this.root = this.options[&#x27;root&#x27;] == null ? exports.GridStore.DEFAULT_ROOT_COLLECTION : this.options[&#x27;root&#x27;];
                          this.position = 0;
                          this.readPreference = this.options.readPreference || &#x27;primary&#x27;;
                          this.writeConcern = _getWriteConcern(db, this.options);
                        
                          // Set default chunk size
                          this.internalChunkSize = this.options[&#x27;chunkSize&#x27;] == null ? Chunk.DEFAULT_CHUNK_SIZE : this.options[&#x27;chunkSize&#x27;];
                        }
                        
                        /**
                         *  Code for the streaming capabilities of the gridstore object
                         *  Most code from Aaron heckmanns project https://github.com/aheckmann/gridfs-stream
                         *  Modified to work on the gridstore object itself
                         *  @ignore
                         */
                        if(typeof Stream == &#x27;function&#x27;) {
                          GridStore.prototype = { __proto__: Stream.prototype }
                        } else {
                          // Node 0.4.X compatibility code
                          GridStore.prototype = { __proto__: Stream.Stream.prototype }
                        }
                        
                        // Move pipe to _pipe
                        GridStore.prototype._pipe = GridStore.prototype.pipe;
                        
                        /**
                         * Opens the file from the database and initialize this object. Also creates a
                         * new one if file does not exist.
                         *
                         * @param {Function} callback this will be called after executing this method. The first parameter will contain an **{Error}** object and the second parameter will be null if an error occured. Otherwise, the first parameter will be null and the second will contain the reference to this object.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.open = function(callback) {
                          if( this.mode != &quot;w&quot; &amp;&amp; this.mode != &quot;w+&quot; &amp;&amp; this.mode != &quot;r&quot;){
                            callback(new Error(&quot;Illegal mode &quot; + this.mode), null);
                            return;
                          }
                        
                          var self = this;
                        
                          // Get the write concern
                          var writeConcern = _getWriteConcern(this.db, this.options);
                        
                          // If we are writing we need to ensure we have the right indexes for md5&#x27;s
                          if((self.mode == &quot;w&quot; || self.mode == &quot;w+&quot;)) {
                            // Get files collection
                            var collection = self.collection();
                            // Put index on filename
                            collection.ensureIndex([[&#x27;filename&#x27;, 1]], writeConcern, function(err, index) {
                              // if(err) return callback(err);
                        
                              // Get chunk collection
                              var chunkCollection = self.chunkCollection();
                              // Ensure index on chunk collection
                              chunkCollection.ensureIndex([[&#x27;files_id&#x27;, 1], [&#x27;n&#x27;, 1]], writeConcern, function(err, index) {
                                // if(err) return callback(err);
                                _open(self, writeConcern, callback);
                              });
                            });
                          } else {
                            // Open the gridstore
                            _open(self, writeConcern, callback);
                          }
                        };
                        
                        /**
                         * Hidding the _open function
                         * @ignore
                         * @api private
                         */
                        var _open = function(self, options, callback) {
                          var collection = self.collection();
                          // Create the query
                          var query = self.referenceBy == REFERENCE_BY_ID ? {_id:self.fileId} : {filename:self.filename};
                          query = null == self.fileId &amp;&amp; self.filename == null ? null : query;
                          options.readPreference = self.readPreference;
                        
                          // Fetch the chunks
                          if(query != null) {
                            collection.findOne(query, options, function(err, doc) {
                              if(err) return error(err);
                        
                              // Check if the collection for the files exists otherwise prepare the new one
                              if(doc != null) {
                                self.fileId = doc._id;
                                // Prefer a new filename over the existing one if this is a write
                                self.filename = ((self.mode == &#x27;r&#x27;) || (self.filename == undefined)) ? doc.filename : self.filename;
                                self.contentType = doc.contentType;
                                self.internalChunkSize = doc.chunkSize;
                                self.uploadDate = doc.uploadDate;
                                self.aliases = doc.aliases;
                                self.length = doc.length;
                                self.metadata = doc.metadata;
                                self.internalMd5 = doc.md5;
                              } else if (self.mode != &#x27;r&#x27;) {
                                self.fileId = self.fileId == null ? new ObjectID() : self.fileId;
                                self.contentType = exports.GridStore.DEFAULT_CONTENT_TYPE;
                                self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
                                self.length = 0;
                              } else {
                                self.length = 0;
                                var txtId = self.fileId instanceof ObjectID ? self.fileId.toHexString() : self.fileId;
                                return error(new Error((self.referenceBy == REFERENCE_BY_ID ? txtId : self.filename) + &quot; does not exist&quot;, self));
                              }
                        
                              // Process the mode of the object
                              if(self.mode == &quot;r&quot;) {
                                nthChunk(self, 0, options, function(err, chunk) {
                                  if(err) return error(err);
                                  self.currentChunk = chunk;
                                  self.position = 0;
                                  callback(null, self);
                                });
                              } else if(self.mode == &quot;w&quot;) {
                                // Delete any existing chunks
                                deleteChunks(self, options, function(err, result) {
                                  if(err) return error(err);
                                  self.currentChunk = new Chunk(self, {&#x27;n&#x27;:0}, self.writeConcern);
                                  self.contentType = self.options[&#x27;content_type&#x27;] == null ? self.contentType : self.options[&#x27;content_type&#x27;];
                                  self.internalChunkSize = self.options[&#x27;chunk_size&#x27;] == null ? self.internalChunkSize : self.options[&#x27;chunk_size&#x27;];
                                  self.metadata = self.options[&#x27;metadata&#x27;] == null ? self.metadata : self.options[&#x27;metadata&#x27;];
                                  self.aliases = self.options[&#x27;aliases&#x27;] == null ? self.aliases : self.options[&#x27;aliases&#x27;];
                                  self.position = 0;
                                  callback(null, self);
                                });
                              } else if(self.mode == &quot;w+&quot;) {
                                nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {
                                  if(err) return error(err);
                                  // Set the current chunk
                                  self.currentChunk = chunk == null ? new Chunk(self, {&#x27;n&#x27;:0}, self.writeConcern) : chunk;
                                  self.currentChunk.position = self.currentChunk.data.length();
                                  self.metadata = self.options[&#x27;metadata&#x27;] == null ? self.metadata : self.options[&#x27;metadata&#x27;];
                                  self.aliases = self.options[&#x27;aliases&#x27;] == null ? self.aliases : self.options[&#x27;aliases&#x27;];
                                  self.position = self.length;
                                  callback(null, self);
                                });
                              }
                            });
                          } else {
                            // Write only mode
                            self.fileId = null == self.fileId ? new ObjectID() : self.fileId;
                            self.contentType = exports.GridStore.DEFAULT_CONTENT_TYPE;
                            self.internalChunkSize = self.internalChunkSize == null ? Chunk.DEFAULT_CHUNK_SIZE : self.internalChunkSize;
                            self.length = 0;
                        
                            var collection2 = self.chunkCollection();
                            // No file exists set up write mode
                            if(self.mode == &quot;w&quot;) {
                              // Delete any existing chunks
                              deleteChunks(self, options, function(err, result) {
                                if(err) return error(err);
                                self.currentChunk = new Chunk(self, {&#x27;n&#x27;:0}, self.writeConcern);
                                self.contentType = self.options[&#x27;content_type&#x27;] == null ? self.contentType : self.options[&#x27;content_type&#x27;];
                                self.internalChunkSize = self.options[&#x27;chunk_size&#x27;] == null ? self.internalChunkSize : self.options[&#x27;chunk_size&#x27;];
                                self.metadata = self.options[&#x27;metadata&#x27;] == null ? self.metadata : self.options[&#x27;metadata&#x27;];
                                self.aliases = self.options[&#x27;aliases&#x27;] == null ? self.aliases : self.options[&#x27;aliases&#x27;];
                                self.position = 0;
                                callback(null, self);
                              });
                            } else if(self.mode == &quot;w+&quot;) {
                              nthChunk(self, lastChunkNumber(self), options, function(err, chunk) {
                                if(err) return error(err);
                                // Set the current chunk
                                self.currentChunk = chunk == null ? new Chunk(self, {&#x27;n&#x27;:0}, self.writeConcern) : chunk;
                                self.currentChunk.position = self.currentChunk.data.length();
                                self.metadata = self.options[&#x27;metadata&#x27;] == null ? self.metadata : self.options[&#x27;metadata&#x27;];
                                self.aliases = self.options[&#x27;aliases&#x27;] == null ? self.aliases : self.options[&#x27;aliases&#x27;];
                                self.position = self.length;
                                callback(null, self);
                              });
                            }
                          }
                        
                          // only pass error to callback once
                          function error (err) {
                            if(error.err) return;
                            callback(error.err = err);
                          }
                        };
                        
                        /**
                         * Stores a file from the file system to the GridFS database.
                         *
                         * @param {String|Buffer|FileHandle} file the file to store.
                         * @param {Function} callback this will be called after this method is executed. The first parameter will be null and the the second will contain the reference to this object.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.writeFile = function (file, callback) {
                          var self = this;
                          if (typeof file === &#x27;string&#x27;) {
                            fs.open(file, &#x27;r&#x27;, function (err, fd) {
                              if(err) return callback(err);
                              self.writeFile(fd, callback);
                            });
                            return;
                          }
                        
                          self.open(function (err, self) {
                            if(err) return callback(err, self);
                        
                            fs.fstat(file, function (err, stats) {
                              if(err) return callback(err, self);
                        
                              var offset = 0;
                              var index = 0;
                              var numberOfChunksLeft = Math.min(stats.size / self.chunkSize);
                        
                              // Write a chunk
                              var writeChunk = function() {
                                fs.read(file, self.chunkSize, offset, &#x27;binary&#x27;, function(err, data, bytesRead) {
                                  if(err) return callback(err, self);
                        
                                  offset = offset + bytesRead;
                        
                                  // Create a new chunk for the data
                                  var chunk = new Chunk(self, {n:index++}, self.writeConcern);
                                  chunk.write(data, function(err, chunk) {
                                    if(err) return callback(err, self);
                        
                                    chunk.save({}, function(err, result) {
                                      if(err) return callback(err, self);
                        
                                      self.position = self.position + data.length;
                        
                                      // Point to current chunk
                                      self.currentChunk = chunk;
                        
                                      if(offset &gt;= stats.size) {
                                        fs.close(file);
                                        self.close(function(err, result) {
                                          if(err) return callback(err, self);
                                          return callback(null, self);
                                        });
                                      } else {
                                        return processor(writeChunk);
                                      }
                                    });
                                  });
                                });
                              }
                        
                              // Process the first write
                              processor(writeChunk);
                            });
                          });
                        };
                        
                        /**
                         * Writes some data. This method will work properly only if initialized with mode
                         * &quot;w&quot; or &quot;w+&quot;.
                         *
                         * @param string {string} The data to write.
                         * @param close {boolean=false} opt_argument Closes this file after writing if
                         *     true.
                         * @param callback {function(*, GridStore)} This will be called after executing
                         *     this method. The first parameter will contain null and the second one
                         *     will contain a reference to this object.
                         *
                         * @ignore
                         * @api private
                         */
                        var writeBuffer = function(self, buffer, close, callback) {
                          if(typeof close === &quot;function&quot;) { callback = close; close = null; }
                          var finalClose = typeof close == &#x27;boolean&#x27; ? close : false;
                        
                          if(self.mode[0] != &quot;w&quot;) {
                            callback(new Error((self.referenceBy == REFERENCE_BY_ID ? self.toHexString() : self.filename) + &quot; not opened for writing&quot;), null);
                          } else {
                            if(self.currentChunk.position + buffer.length &gt;= self.chunkSize) {
                              // Write out the current Chunk and then keep writing until we have less data left than a chunkSize left
                              // to a new chunk (recursively)
                              var previousChunkNumber = self.currentChunk.chunkNumber;
                              var leftOverDataSize = self.chunkSize - self.currentChunk.position;
                              var firstChunkData = buffer.slice(0, leftOverDataSize);
                              var leftOverData = buffer.slice(leftOverDataSize);
                              // A list of chunks to write out
                              var chunksToWrite = [self.currentChunk.write(firstChunkData)];
                              // If we have more data left than the chunk size let&#x27;s keep writing new chunks
                              while(leftOverData.length &gt;= self.chunkSize) {
                                // Create a new chunk and write to it
                                var newChunk = new Chunk(self, {&#x27;n&#x27;: (previousChunkNumber + 1)}, self.writeConcern);
                                var firstChunkData = leftOverData.slice(0, self.chunkSize);
                                leftOverData = leftOverData.slice(self.chunkSize);
                                // Update chunk number
                                previousChunkNumber = previousChunkNumber + 1;
                                // Write data
                                newChunk.write(firstChunkData);
                                // Push chunk to save list
                                chunksToWrite.push(newChunk);
                              }
                        
                              // Set current chunk with remaining data
                              self.currentChunk = new Chunk(self, {&#x27;n&#x27;: (previousChunkNumber + 1)}, self.writeConcern);
                              // If we have left over data write it
                              if(leftOverData.length &gt; 0) self.currentChunk.write(leftOverData);
                        
                              // Update the position for the gridstore
                              self.position = self.position + buffer.length;
                              // Total number of chunks to write
                              var numberOfChunksToWrite = chunksToWrite.length;
                        
                              for(var i = 0; i &lt; chunksToWrite.length; i++) {
                                chunksToWrite[i].save({}, function(err, result) {
                                  if(err) return callback(err);
                        
                                  numberOfChunksToWrite = numberOfChunksToWrite - 1;
                        
                                  if(numberOfChunksToWrite &lt;= 0) {
                                    // We care closing the file before returning
                                    if(finalClose) {
                                      return self.close(function(err, result) {
                                        callback(err, self);
                                      });
                                    }
                        
                                    // Return normally
                                    return callback(null, self);
                                  }
                                });
                              }
                            } else {
                              // Update the position for the gridstore
                              self.position = self.position + buffer.length;
                              // We have less data than the chunk size just write it and callback
                              self.currentChunk.write(buffer);
                              // We care closing the file before returning
                              if(finalClose) {
                                return self.close(function(err, result) {
                                  callback(err, self);
                                });
                              }
                              // Return normally
                              return callback(null, self);
                            }
                          }
                        };
                        
                        /**
                         * Creates a mongoDB object representation of this object.
                         *
                         * @param callback {function(object)} This will be called after executing this
                         *     method. The object will be passed to the first parameter and will have
                         *     the structure:
                         *
                         *        &lt;pre&gt;&lt;code&gt;
                         *        {
                         *          &#x27;_id&#x27; : , // {number} id for this file
                         *          &#x27;filename&#x27; : , // {string} name for this file
                         *          &#x27;contentType&#x27; : , // {string} mime type for this file
                         *          &#x27;length&#x27; : , // {number} size of this file?
                         *          &#x27;chunksize&#x27; : , // {number} chunk size used by this file
                         *          &#x27;uploadDate&#x27; : , // {Date}
                         *          &#x27;aliases&#x27; : , // {array of string}
                         *          &#x27;metadata&#x27; : , // {string}
                         *        }
                         *        &lt;/code&gt;&lt;/pre&gt;
                         *
                         * @ignore
                         * @api private
                         */
                        var buildMongoObject = function(self, callback) {
                          // Calcuate the length
                          var mongoObject = {
                            &#x27;_id&#x27;: self.fileId,
                            &#x27;filename&#x27;: self.filename,
                            &#x27;contentType&#x27;: self.contentType,
                            &#x27;length&#x27;: self.position ? self.position : 0,
                            &#x27;chunkSize&#x27;: self.chunkSize,
                            &#x27;uploadDate&#x27;: self.uploadDate,
                            &#x27;aliases&#x27;: self.aliases,
                            &#x27;metadata&#x27;: self.metadata
                          };
                        
                          var md5Command = {filemd5:self.fileId, root:self.root};
                          self.db.command(md5Command, function(err, results) {
                            if(err) return callback(err);
                        
                            mongoObject.md5 = results.md5;
                            callback(null, mongoObject);
                          });
                        };
                        
                        /**
                         * Saves this file to the database. This will overwrite the old entry if it
                         * already exists. This will work properly only if mode was initialized to
                         * &quot;w&quot; or &quot;w+&quot;.
                         *
                         * @param {Function} callback this will be called after executing this method. Passes an **{Error}** object to the first parameter and null to the second if an error occured. Otherwise, passes null to the first and a reference to this object to the second.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.close = function(callback) {
                          var self = this;
                        
                          if(self.mode[0] == &quot;w&quot;) {
                            // Set up options
                            var options = self.writeConcern;
                        
                            if(self.currentChunk != null &amp;&amp; self.currentChunk.position &gt; 0) {
                              self.currentChunk.save({}, function(err, chunk) {
                                if(err &amp;&amp; typeof callback == &#x27;function&#x27;) return callback(err);
                        
                                self.collection(function(err, files) {
                                  if(err &amp;&amp; typeof callback == &#x27;function&#x27;) return callback(err);
                        
                                  // Build the mongo object
                                  if(self.uploadDate != null) {
                                    files.remove({&#x27;_id&#x27;:self.fileId}, self.writeConcern, function(err, collection) {
                                      if(err &amp;&amp; typeof callback == &#x27;function&#x27;) return callback(err);
                        
                                      buildMongoObject(self, function(err, mongoObject) {
                                        if(err) {
                                          if(typeof callback == &#x27;function&#x27;) return callback(err); else throw err;
                                        }
                        
                                        files.save(mongoObject, options, function(err) {
                                          if(typeof callback == &#x27;function&#x27;)
                                            callback(err, mongoObject);
                                        });
                                      });
                                    });
                                  } else {
                                    self.uploadDate = new Date();
                                    buildMongoObject(self, function(err, mongoObject) {
                                      if(err) {
                                        if(typeof callback == &#x27;function&#x27;) return callback(err); else throw err;
                                      }
                        
                                      files.save(mongoObject, options, function(err) {
                                        if(typeof callback == &#x27;function&#x27;)
                                          callback(err, mongoObject);
                                      });
                                    });
                                  }
                                });
                              });
                            } else {
                              self.collection(function(err, files) {
                                if(err &amp;&amp; typeof callback == &#x27;function&#x27;) return callback(err);
                        
                                self.uploadDate = new Date();
                                buildMongoObject(self, function(err, mongoObject) {
                                  if(err) {
                                    if(typeof callback == &#x27;function&#x27;) return callback(err); else throw err;
                                  }
                        
                                  files.save(mongoObject, options, function(err) {
                                    if(typeof callback == &#x27;function&#x27;)
                                      callback(err, mongoObject);
                                  });
                                });
                              });
                            }
                          } else if(self.mode[0] == &quot;r&quot;) {
                            if(typeof callback == &#x27;function&#x27;)
                              callback(null, null);
                          } else {
                            if(typeof callback == &#x27;function&#x27;)
                              callback(new Error(&quot;Illegal mode &quot; + self.mode), null);
                          }
                        };
                        
                        /**
                         * Gets the nth chunk of this file.
                         *
                         * @param chunkNumber {number} The nth chunk to retrieve.
                         * @param callback {function(*, Chunk|object)} This will be called after
                         *     executing this method. null will be passed to the first parameter while
                         *     a new {@link Chunk} instance will be passed to the second parameter if
                         *     the chunk was found or an empty object {} if not.
                         *
                         * @ignore
                         * @api private
                         */
                        var nthChunk = function(self, chunkNumber, options, callback) {
                          if(typeof options == &#x27;function&#x27;) {
                            callback = options;
                            options = {};
                          }
                        
                          options = options || self.writeConcern;
                          options.readPreference = self.readPreference;
                          // Get the nth chunk
                          self.chunkCollection().findOne({&#x27;files_id&#x27;:self.fileId, &#x27;n&#x27;:chunkNumber}, options, function(err, chunk) {
                            if(err) return callback(err);
                        
                            var finalChunk = chunk == null ? {} : chunk;
                            callback(null, new Chunk(self, finalChunk, self.writeConcern));
                          });
                        };
                        
                        /**
                         *
                         * @ignore
                         * @api private
                         */
                        GridStore.prototype._nthChunk = function(chunkNumber, callback) {
                          nthChunk(this, chunkNumber, callback);
                        }
                        
                        /**
                         * @return {Number} The last chunk number of this file.
                         *
                         * @ignore
                         * @api private
                         */
                        var lastChunkNumber = function(self) {
                          return Math.floor((self.length ? self.length - 1 : 0)/self.chunkSize);
                        };
                        
                        /**
                         * Retrieve this file&#x27;s chunks collection.
                         *
                         * @param {Function} callback this will be called after executing this method. An exception object will be passed to the first parameter when an error occured or null otherwise. A new **{Collection}** object will be passed to the second parameter if no error occured.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.chunkCollection = function(callback) {
                          if(typeof callback == &#x27;function&#x27;)
                            return this.db.collection((this.root + &quot;.chunks&quot;), callback);
                          return this.db.collection((this.root + &quot;.chunks&quot;));
                        };
                        
                        /**
                         * Deletes all the chunks of this file in the database.
                         *
                         * @param callback {function(*, boolean)} This will be called after this method
                         *     executes. Passes null to the first and true to the second argument.
                         *
                         * @ignore
                         * @api private
                         */
                        var deleteChunks = function(self, options, callback) {
                          if(typeof options == &#x27;function&#x27;) {
                            callback = options;
                            options = {};
                          }
                        
                          options = options || self.writeConcern;
                        
                          if(self.fileId != null) {
                            self.chunkCollection().remove({&#x27;files_id&#x27;:self.fileId}, options, function(err, result) {
                              if(err) return callback(err, false);
                              callback(null, true);
                            });
                          } else {
                            callback(null, true);
                          }
                        };
                        
                        /**
                         * Deletes all the chunks of this file in the database.
                         *
                         * @param {Function} callback this will be called after this method executes. Passes null to the first and true to the second argument.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.unlink = function(callback) {
                          var self = this;
                          deleteChunks(this, function(err) {
                            if(err!==null) {
                              err.message = &quot;at deleteChunks: &quot; + err.message;
                              return callback(err);
                            }
                        
                            self.collection(function(err, collection) {
                              if(err!==null) {
                                err.message = &quot;at collection: &quot; + err.message;
                                return callback(err);
                              }
                        
                              collection.remove({&#x27;_id&#x27;:self.fileId}, self.writeConcern, function(err) {
                                callback(err, self);
                              });
                            });
                          });
                        };
                        
                        /**
                         * Retrieves the file collection associated with this object.
                         *
                         * @param {Function} callback this will be called after executing this method. An exception object will be passed to the first parameter when an error occured or null otherwise. A new **{Collection}** object will be passed to the second parameter if no error occured.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.collection = function(callback) {
                          if(typeof callback == &#x27;function&#x27;)
                            this.db.collection(this.root + &quot;.files&quot;, callback);
                          return this.db.collection(this.root + &quot;.files&quot;);
                        };
                        
                        /**
                         * Reads the data of this file.
                         *
                         * @param {String} [separator] the character to be recognized as the newline separator.
                         * @param {Function} callback This will be called after this method is executed. The first parameter will be null and the second parameter will contain an array of strings representing the entire data, each element representing a line including the separator character.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.readlines = function(separator, callback) {
                          var args = Array.prototype.slice.call(arguments, 0);
                          callback = args.pop();
                          separator = args.length ? args.shift() : &quot;\n&quot;;
                        
                          this.read(function(err, data) {
                            if(err) return callback(err);
                        
                            var items = data.toString().split(separator);
                            items = items.length &gt; 0 ? items.splice(0, items.length - 1) : [];
                            for(var i = 0; i &lt; items.length; i++) {
                              items[i] = items[i] + separator;
                            }
                        
                            callback(null, items);
                          });
                        };
                        
                        /**
                         * Deletes all the chunks of this file in the database if mode was set to &quot;w&quot; or
                         * &quot;w+&quot; and resets the read/write head to the initial position.
                         *
                         * @param {Function} callback this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.rewind = function(callback) {
                          var self = this;
                        
                          if(this.currentChunk.chunkNumber != 0) {
                            if(this.mode[0] == &quot;w&quot;) {
                              deleteChunks(self, function(err, gridStore) {
                                if(err) return callback(err);
                                self.currentChunk = new Chunk(self, {&#x27;n&#x27;: 0}, self.writeConcern);
                                self.position = 0;
                                callback(null, self);
                              });
                            } else {
                              self.currentChunk(0, function(err, chunk) {
                                if(err) return callback(err);
                                self.currentChunk = chunk;
                                self.currentChunk.rewind();
                                self.position = 0;
                                callback(null, self);
                              });
                            }
                          } else {
                            self.currentChunk.rewind();
                            self.position = 0;
                            callback(null, self);
                          }
                        };
                        
                        /**
                         * Retrieves the contents of this file and advances the read/write head. Works with Buffers only.
                         *
                         * There are 3 signatures for this method:
                         *
                         * (callback)
                         * (length, callback)
                         * (length, buffer, callback)
                         *
                         * @param {Number} [length] the number of characters to read. Reads all the characters from the read/write head to the EOF if not specified.
                         * @param {String|Buffer} [buffer] a string to hold temporary data. This is used for storing the string data read so far when recursively calling this method.
                         * @param {Function} callback this will be called after this method is executed. null will be passed to the first parameter and a string containing the contents of the buffer concatenated with the contents read from this file will be passed to the second.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.read = function(length, buffer, callback) {
                          var self = this;
                        
                          var args = Array.prototype.slice.call(arguments, 0);
                          callback = args.pop();
                          length = args.length ? args.shift() : null;
                          buffer = args.length ? args.shift() : null;
                        
                          // The data is a c-terminated string and thus the length - 1
                          var finalLength = length == null ? self.length - self.position : length;
                          var finalBuffer = buffer == null ? new Buffer(finalLength) : buffer;
                          // Add a index to buffer to keep track of writing position or apply current index
                          finalBuffer._index = buffer != null &amp;&amp; buffer._index != null ? buffer._index : 0;
                        
                          if((self.currentChunk.length() - self.currentChunk.position + finalBuffer._index) &gt;= finalLength) {
                            var slice = self.currentChunk.readSlice(finalLength - finalBuffer._index);
                            // Copy content to final buffer
                            slice.copy(finalBuffer, finalBuffer._index);
                            // Update internal position
                            self.position = self.position + finalBuffer.length;
                            // Check if we don&#x27;t have a file at all
                            if(finalLength == 0 &amp;&amp; finalBuffer.length == 0) return callback(new Error(&quot;File does not exist&quot;), null);
                            // Else return data
                            callback(null, finalBuffer);
                          } else {
                            var slice = self.currentChunk.readSlice(self.currentChunk.length() - self.currentChunk.position);
                            // Copy content to final buffer
                            slice.copy(finalBuffer, finalBuffer._index);
                            // Update index position
                            finalBuffer._index += slice.length;
                        
                            // Load next chunk and read more
                            nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
                              if(err) return callback(err);
                        
                              if(chunk.length() &gt; 0) {
                                self.currentChunk = chunk;
                                self.read(length, finalBuffer, callback);
                              } else {
                                if (finalBuffer._index &gt; 0) {
                                  callback(null, finalBuffer)
                                } else {
                                  callback(new Error(&quot;no chunks found for file, possibly corrupt&quot;), null);
                                }
                              }
                            });
                          }
                        }
                        
                        /**
                         * Retrieves the position of the read/write head of this file.
                         *
                         * @param {Function} callback This gets called after this method terminates. null is passed to the first parameter and the position is passed to the second.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.tell = function(callback) {
                          callback(null, this.position);
                        };
                        
                        /**
                         * Moves the read/write head to a new location.
                         *
                         * There are 3 signatures for this method
                         *
                         * Seek Location Modes
                         *  - **GridStore.IO_SEEK_SET**, **(default)** set the position from the start of the file.
                         *  - **GridStore.IO_SEEK_CUR**, set the position from the current position in the file.
                         *  - **GridStore.IO_SEEK_END**, set the position from the end of the file.
                         *
                         * @param {Number} [position] the position to seek to
                         * @param {Number} [seekLocation] seek mode. Use one of the Seek Location modes.
                         * @param {Function} callback this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.seek = function(position, seekLocation, callback) {
                          var self = this;
                        
                          var args = Array.prototype.slice.call(arguments, 1);
                          callback = args.pop();
                          seekLocation = args.length ? args.shift() : null;
                        
                          var seekLocationFinal = seekLocation == null ? exports.GridStore.IO_SEEK_SET : seekLocation;
                          var finalPosition = position;
                          var targetPosition = 0;
                        
                          // Calculate the position
                          if(seekLocationFinal == exports.GridStore.IO_SEEK_CUR) {
                            targetPosition = self.position + finalPosition;
                          } else if(seekLocationFinal == exports.GridStore.IO_SEEK_END) {
                            targetPosition = self.length + finalPosition;
                          } else {
                            targetPosition = finalPosition;
                          }
                        
                          // Get the chunk
                          var newChunkNumber = Math.floor(targetPosition/self.chunkSize);
                          if(newChunkNumber != self.currentChunk.chunkNumber) {
                            var seekChunk = function() {
                              nthChunk(self, newChunkNumber, function(err, chunk) {
                                self.currentChunk = chunk;
                                self.position = targetPosition;
                                self.currentChunk.position = (self.position % self.chunkSize);
                                callback(err, self);
                              });
                            };
                        
                            if(self.mode[0] == &#x27;w&#x27;) {
                              self.currentChunk.save({}, function(err) {
                                if(err) return callback(err);
                                seekChunk();
                              });
                            } else {
                              seekChunk();
                            }
                          } else {
                            self.position = targetPosition;
                            self.currentChunk.position = (self.position % self.chunkSize);
                            callback(null, self);
                          }
                        };
                        
                        /**
                         * Verify if the file is at EOF.
                         *
                         * @return {Boolean} true if the read/write head is at the end of this file.
                         * @api public
                         */
                        GridStore.prototype.eof = function() {
                          return this.position == this.length ? true : false;
                        };
                        
                        /**
                         * Retrieves a single character from this file.
                         *
                         * @param {Function} callback this gets called after this method is executed. Passes null to the first parameter and the character read to the second or null to the second if the read/write head is at the end of the file.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.getc = function(callback) {
                          var self = this;
                        
                          if(self.eof()) {
                            callback(null, null);
                          } else if(self.currentChunk.eof()) {
                            nthChunk(self, self.currentChunk.chunkNumber + 1, function(err, chunk) {
                              self.currentChunk = chunk;
                              self.position = self.position + 1;
                              callback(err, self.currentChunk.getc());
                            });
                          } else {
                            self.position = self.position + 1;
                            callback(null, self.currentChunk.getc());
                          }
                        };
                        
                        /**
                         * Writes a string to the file with a newline character appended at the end if
                         * the given string does not have one.
                         *
                         * @param {String} string the string to write.
                         * @param {Function} callback this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.puts = function(string, callback) {
                          var finalString = string.match(/\n$/) == null ? string + &quot;\n&quot; : string;
                          this.write(finalString, callback);
                        };
                        
                        /**
                         * Returns read stream based on this GridStore file
                         *
                         * Events
                         *  - **data** {function(item) {}} the data event triggers when a document is ready.
                         *  - **end** {function() {}} the end event triggers when there is no more documents available.
                         *  - **close** {function() {}} the close event triggers when the stream is closed.
                         *  - **error** {function(err) {}} the error event triggers if an error happens.
                         *
                         * @param {Boolean} autoclose if true current GridStore will be closed when EOF and &#x27;close&#x27; event will be fired
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.stream = function(autoclose) {
                          return new ReadStream(autoclose, this);
                        };
                        
                        /**
                        * The collection to be used for holding the files and chunks collection.
                        *
                        * @classconstant DEFAULT_ROOT_COLLECTION
                        **/
                        GridStore.DEFAULT_ROOT_COLLECTION = &#x27;fs&#x27;;
                        
                        /**
                        * Default file mime type
                        *
                        * @classconstant DEFAULT_CONTENT_TYPE
                        **/
                        GridStore.DEFAULT_CONTENT_TYPE = &#x27;binary/octet-stream&#x27;;
                        
                        /**
                        * Seek mode where the given length is absolute.
                        *
                        * @classconstant IO_SEEK_SET
                        **/
                        GridStore.IO_SEEK_SET = 0;
                        
                        /**
                        * Seek mode where the given length is an offset to the current read/write head.
                        *
                        * @classconstant IO_SEEK_CUR
                        **/
                        GridStore.IO_SEEK_CUR = 1;
                        
                        /**
                        * Seek mode where the given length is an offset to the end of the file.
                        *
                        * @classconstant IO_SEEK_END
                        **/
                        GridStore.IO_SEEK_END = 2;
                        
                        /**
                         * Checks if a file exists in the database.
                         *
                         * Options
                         *  - **readPreference** {String}, the prefered read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
                         *
                         * @param {Db} db the database to query.
                         * @param {String} name the name of the file to look for.
                         * @param {String} [rootCollection] the root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
                         * @param {Function} callback this will be called after this method executes. Passes null to the first and passes true to the second if the file exists and false otherwise.
                         * @return {null}
                         * @api public
                         */
                        GridStore.exist = function(db, fileIdObject, rootCollection, options, callback) {
                          var args = Array.prototype.slice.call(arguments, 2);
                          callback = args.pop();
                          rootCollection = args.length ? args.shift() : null;
                          options = args.length ? args.shift() : {};
                        
                          // Establish read preference
                          var readPreference = options.readPreference || &#x27;primary&#x27;;
                          // Fetch collection
                          var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
                          db.collection(rootCollectionFinal + &quot;.files&quot;, function(err, collection) {
                            if(err) return callback(err);
                        
                            // Build query
                            var query = (typeof fileIdObject == &#x27;string&#x27; || Object.prototype.toString.call(fileIdObject) == &#x27;[object RegExp]&#x27; )
                              ? {&#x27;filename&#x27;:fileIdObject}
                              : {&#x27;_id&#x27;:fileIdObject};    // Attempt to locate file
                        
                            collection.findOne(query, {readPreference:readPreference}, function(err, item) {
                              if(err) return callback(err);
                        
                              callback(null, item == null ? false : true);
                            });
                          });
                        };
                        
                        /**
                         * Gets the list of files stored in the GridFS.
                         *
                         * @param {Db} db the database to query.
                         * @param {String} [rootCollection] the root collection that holds the files and chunks collection. Defaults to **{GridStore.DEFAULT_ROOT_COLLECTION}**.
                         * @param {Function} callback this will be called after this method executes. Passes null to the first and passes an array of strings containing the names of the files.
                         * @return {null}
                         * @api public
                         */
                        GridStore.list = function(db, rootCollection, options, callback) {
                          var args = Array.prototype.slice.call(arguments, 1);
                          callback = args.pop();
                          rootCollection = args.length ? args.shift() : null;
                          options = args.length ? args.shift() : {};
                        
                          // Ensure we have correct values
                          if(rootCollection != null &amp;&amp; typeof rootCollection == &#x27;object&#x27;) {
                            options = rootCollection;
                            rootCollection = null;
                          }
                        
                          // Establish read preference
                          var readPreference = options.readPreference || &#x27;primary&#x27;;
                          // Check if we are returning by id not filename
                          var byId = options[&#x27;id&#x27;] != null ? options[&#x27;id&#x27;] : false;
                          // Fetch item
                          var rootCollectionFinal = rootCollection != null ? rootCollection : GridStore.DEFAULT_ROOT_COLLECTION;
                          var items = [];
                          db.collection((rootCollectionFinal + &quot;.files&quot;), function(err, collection) {
                            if(err) return callback(err);
                        
                            collection.find({}, {readPreference:readPreference}, function(err, cursor) {
                              if(err) return callback(err);
                        
                              cursor.each(function(err, item) {
                                if(item != null) {
                                  items.push(byId ? item._id : item.filename);
                                } else {
                                  callback(err, items);
                                }
                              });
                            });
                          });
                        };
                        
                        /**
                         * Reads the contents of a file.
                         *
                         * This method has the following signatures
                         *
                         * (db, name, callback)
                         * (db, name, length, callback)
                         * (db, name, length, offset, callback)
                         * (db, name, length, offset, options, callback)
                         *
                         * @param {Db} db the database to query.
                         * @param {String} name the name of the file.
                         * @param {Number} [length] the size of data to read.
                         * @param {Number} [offset] the offset from the head of the file of which to start reading from.
                         * @param {Object} [options] the options for the file.
                         * @param {Function} callback this will be called after this method executes. A string with an error message will be passed to the first parameter when the length and offset combination exceeds the length of the file while an Error object will be passed if other forms of error occured, otherwise, a string is passed. The second parameter will contain the data read if successful or null if an error occured.
                         * @return {null}
                         * @api public
                         */
                        GridStore.read = function(db, name, length, offset, options, callback) {
                          var args = Array.prototype.slice.call(arguments, 2);
                          callback = args.pop();
                          length = args.length ? args.shift() : null;
                          offset = args.length ? args.shift() : null;
                          options = args.length ? args.shift() : null;
                        
                          new GridStore(db, name, &quot;r&quot;, options).open(function(err, gridStore) {
                            if(err) return callback(err);
                            // Make sure we are not reading out of bounds
                            if(offset &amp;&amp; offset &gt;= gridStore.length) return callback(&quot;offset larger than size of file&quot;, null);
                            if(length &amp;&amp; length &gt; gridStore.length) return callback(&quot;length is larger than the size of the file&quot;, null);
                            if(offset &amp;&amp; length &amp;&amp; (offset + length) &gt; gridStore.length) return callback(&quot;offset and length is larger than the size of the file&quot;, null);
                        
                            if(offset != null) {
                              gridStore.seek(offset, function(err, gridStore) {
                                if(err) return callback(err);
                                gridStore.read(length, callback);
                              });
                            } else {
                              gridStore.read(length, callback);
                            }
                          });
                        };
                        
                        /**
                         * Reads the data of this file.
                         *
                         * @param {Db} db the database to query.
                         * @param {String} name the name of the file.
                         * @param {String} [separator] the character to be recognized as the newline separator.
                         * @param {Object} [options] file options.
                         * @param {Function} callback this will be called after this method is executed. The first parameter will be null and the second parameter will contain an array of strings representing the entire data, each element representing a line including the separator character.
                         * @return {null}
                         * @api public
                         */
                        GridStore.readlines = function(db, name, separator, options, callback) {
                          var args = Array.prototype.slice.call(arguments, 2);
                          callback = args.pop();
                          separator = args.length ? args.shift() : null;
                          options = args.length ? args.shift() : null;
                        
                          var finalSeperator = separator == null ? &quot;\n&quot; : separator;
                          new GridStore(db, name, &quot;r&quot;, options).open(function(err, gridStore) {
                            if(err) return callback(err);
                            gridStore.readlines(finalSeperator, callback);
                          });
                        };
                        
                        /**
                         * Deletes the chunks and metadata information of a file from GridFS.
                         *
                         * @param {Db} db the database to interact with.
                         * @param {String|Array} names the name/names of the files to delete.
                         * @param {Object} [options] the options for the files.
                         * @callback {Function} this will be called after this method is executed. The first parameter will contain an Error object if an error occured or null otherwise. The second parameter will contain a reference to this object.
                         * @return {null}
                         * @api public
                         */
                        GridStore.unlink = function(db, names, options, callback) {
                          var self = this;
                          var args = Array.prototype.slice.call(arguments, 2);
                          callback = args.pop();
                          options = args.length ? args.shift() : {};
                        
                          // Get the write concern
                          var writeConcern = _getWriteConcern(db, options);
                        
                          // List of names
                          if(names.constructor == Array) {
                            var tc = 0;
                            for(var i = 0; i &lt; names.length; i++) {
                              ++tc;
                              GridStore.unlink(db, names[i], options, function(result) {
                                if(--tc == 0) {
                                    callback(null, self);
                                }
                              });
                            }
                          } else {
                            new GridStore(db, names, &quot;w&quot;, options).open(function(err, gridStore) {
                              if(err) return callback(err);
                              deleteChunks(gridStore, function(err, result) {
                                if(err) return callback(err);
                                gridStore.collection(function(err, collection) {
                                  if(err) return callback(err);
                                  collection.remove({&#x27;_id&#x27;:gridStore.fileId}, writeConcern, function(err, result) {
                                    callback(err, self);
                                  });
                                });
                              });
                            });
                          }
                        };
                        
                        /**
                         * Returns the current chunksize of the file.
                         *
                         * @field chunkSize
                         * @type {Number}
                         * @getter
                         * @setter
                         * @property return number of bytes in the current chunkSize.
                         */
                        Object.defineProperty(GridStore.prototype, &quot;chunkSize&quot;, { enumerable: true
                         , get: function () {
                             return this.internalChunkSize;
                           }
                         , set: function(value) {
                             if(!(this.mode[0] == &quot;w&quot; &amp;&amp; this.position == 0 &amp;&amp; this.uploadDate == null)) {
                               this.internalChunkSize = this.internalChunkSize;
                             } else {
                               this.internalChunkSize = value;
                             }
                           }
                        });
                        
                        /**
                         * The md5 checksum for this file.
                         *
                         * @field md5
                         * @type {Number}
                         * @getter
                         * @setter
                         * @property return this files md5 checksum.
                         */
                        Object.defineProperty(GridStore.prototype, &quot;md5&quot;, { enumerable: true
                         , get: function () {
                             return this.internalMd5;
                           }
                        });
                        
                        /**
                         *  GridStore Streaming methods
                         *  Handles the correct return of the writeable stream status
                         *  @ignore
                         */
                        Object.defineProperty(GridStore.prototype, &quot;writable&quot;, { enumerable: true
                         , get: function () {
                            if(this._writeable == null) {
                              this._writeable = this.mode != null &amp;&amp; this.mode.indexOf(&quot;w&quot;) != -1;
                            }
                            // Return the _writeable
                            return this._writeable;
                          }
                         , set: function(value) {
                            this._writeable = value;
                          }
                        });
                        
                        /**
                         *  Handles the correct return of the readable stream status
                         *  @ignore
                         */
                        Object.defineProperty(GridStore.prototype, &quot;readable&quot;, { enumerable: true
                         , get: function () {
                            if(this._readable == null) {
                              this._readable = this.mode != null &amp;&amp; this.mode.indexOf(&quot;r&quot;) != -1;
                            }
                            return this._readable;
                          }
                         , set: function(value) {
                            this._readable = value;
                          }
                        });
                        
                        GridStore.prototype.paused;
                        
                        /**
                         *  Handles the correct setting of encoding for the stream
                         *  @ignore
                         */
                        GridStore.prototype.setEncoding = fs.ReadStream.prototype.setEncoding;
                        
                        /**
                         *  Handles the end events
                         *  @ignore
                         */
                        GridStore.prototype.end = function end(data) {
                          var self = this;
                          // allow queued data to write before closing
                          if(!this.writable) return;
                          this.writable = false;
                        
                          if(data) {
                            this._q.push(data);
                          }
                        
                          this.on(&#x27;drain&#x27;, function () {
                            self.close(function (err) {
                              if (err) return _error(self, err);
                              self.emit(&#x27;close&#x27;);
                            });
                          });
                        
                          _flush(self);
                        }
                        
                        /**
                         *  Handles the normal writes to gridstore
                         *  @ignore
                         */
                        var _writeNormal = function(self, data, close, callback) {
                          // If we have a buffer write it using the writeBuffer method
                          if(Buffer.isBuffer(data)) {
                            return writeBuffer(self, data, close, callback);
                          } else {
                            return writeBuffer(self, new Buffer(data, &#x27;binary&#x27;), close, callback);
                          }
                        }
                        
                        /**
                         * Writes some data. This method will work properly only if initialized with mode &quot;w&quot; or &quot;w+&quot;.
                         *
                         * @param {String|Buffer} data the data to write.
                         * @param {Boolean} [close] closes this file after writing if set to true.
                         * @param {Function} callback this will be called after executing this method. The first parameter will contain null and the second one will contain a reference to this object.
                         * @return {null}
                         * @api public
                         */
                        GridStore.prototype.write = function write(data, close, callback) {
                          // If it&#x27;s a normal write delegate the call
                          if(typeof close == &#x27;function&#x27; || typeof callback == &#x27;function&#x27;) {
                            return _writeNormal(this, data, close, callback);
                          }
                        
                          // Otherwise it&#x27;s a stream write
                          var self = this;
                          if (!this.writable) {
                            throw new Error(&#x27;GridWriteStream is not writable&#x27;);
                          }
                        
                          // queue data until we open.
                          if(!this._opened) {
                            // Set up a queue to save data until gridstore object is ready
                            this._q = [];
                            _openStream(self);
                            this._q.push(data);
                            return false;
                          }
                        
                          // Push data to queue
                          this._q.push(data);
                          _flush(this);
                          // Return write successful
                          return true;
                        }
                        
                        /**
                         *  Handles the destroy part of a stream
                         *  @ignore
                         */
                        GridStore.prototype.destroy = function destroy() {
                          // close and do not emit any more events. queued data is not sent.
                          if(!this.writable) return;
                          this.readable = false;
                          if(this.writable) {
                            this.writable = false;
                            this._q.length = 0;
                            this.emit(&#x27;close&#x27;);
                          }
                        }
                        
                        /**
                         *  Handles the destroySoon part of a stream
                         *  @ignore
                         */
                        GridStore.prototype.destroySoon = function destroySoon() {
                          // as soon as write queue is drained, destroy.
                          // may call destroy immediately if no data is queued.
                          if(!this._q.length) {
                            return this.destroy();
                          }
                          this._destroying = true;
                        }
                        
                        /**
                         *  Handles the pipe part of the stream
                         *  @ignore
                         */
                        GridStore.prototype.pipe = function(destination, options) {
                          var self = this;
                          // Open the gridstore
                          this.open(function(err, result) {
                            if(err) _errorRead(self, err);
                            if(!self.readable) return;
                            // Set up the pipe
                            self._pipe(destination, options);
                            // Emit the stream is open
                            self.emit(&#x27;open&#x27;);
                            // Read from the stream
                            _read(self);
                          });
                          return destination;
                        }
                        
                        /**
                         *  Internal module methods
                         *  @ignore
                         */
                        var _read = function _read(self) {
                          if (!self.readable || self.paused || self.reading) {
                            return;
                          }
                        
                          self.reading = true;
                          var stream = self._stream = self.stream();
                          stream.paused = self.paused;
                        
                          stream.on(&#x27;data&#x27;, function (data) {
                            if (self._decoder) {
                              var str = self._decoder.write(data);
                              if (str.length) self.emit(&#x27;data&#x27;, str);
                            } else {
                              self.emit(&#x27;data&#x27;, data);
                            }
                          });
                        
                          stream.on(&#x27;end&#x27;, function (data) {
                            self.emit(&#x27;end&#x27;, data);
                          });
                        
                          stream.on(&#x27;error&#x27;, function (data) {
                            _errorRead(self, data);
                          });
                        
                          stream.on(&#x27;close&#x27;, function (data) {
                            self.emit(&#x27;close&#x27;, data);
                          });
                        
                          self.pause = function () {
                            // native doesn&#x27;t always pause.
                            // bypass its pause() method to hack it
                            self.paused = stream.paused = true;
                          }
                        
                          self.resume = function () {
                            if(!self.paused) return;
                        
                            self.paused = false;
                            stream.resume();
                            self.readable = stream.readable;
                          }
                        
                          self.destroy = function () {
                            self.readable = false;
                            stream.destroy();
                          }
                        }
                        
                        /**
                         * pause
                         * @ignore
                         */
                        GridStore.prototype.pause = function pause () {
                          // Overridden when the GridStore opens.
                          this.paused = true;
                        }
                        
                        /**
                         * resume
                         * @ignore
                         */
                        GridStore.prototype.resume = function resume () {
                          // Overridden when the GridStore opens.
                          this.paused = false;
                        }
                        
                        /**
                         *  Internal module methods
                         *  @ignore
                         */
                        var _flush = function _flush(self, _force) {
                          if (!self._opened) return;
                          if (!_force &amp;&amp; self._flushing) return;
                          self._flushing = true;
                        
                          // write the entire q to gridfs
                          if (!self._q.length) {
                            self._flushing = false;
                            self.emit(&#x27;drain&#x27;);
                        
                            if(self._destroying) {
                              self.destroy();
                            }
                            return;
                          }
                        
                          self.write(self._q.shift(), function (err, store) {
                            if (err) return _error(self, err);
                            self.emit(&#x27;progress&#x27;, store.position);
                            _flush(self, true);
                          });
                        }
                        
                        var _openStream = function _openStream (self) {
                          if(self._opening == true) return;
                          self._opening = true;
                        
                          // Open the store
                          self.open(function (err, gridstore) {
                            if (err) return _error(self, err);
                            self._opened = true;
                            self.emit(&#x27;open&#x27;);
                            _flush(self);
                          });
                        }
                        
                        var _error = function _error(self, err) {
                          self.destroy();
                          self.emit(&#x27;error&#x27;, err);
                        }
                        
                        var _errorRead = function _errorRead (self, err) {
                          self.readable = false;
                          self.emit(&#x27;error&#x27;, err);
                        }
                        
                        /**
                         * @ignore
                         */
                        var _hasWriteConcern = function(errorOptions) {
                          return errorOptions == true
                            || errorOptions.w &gt; 0
                            || errorOptions.w == &#x27;majority&#x27;
                            || errorOptions.j == true
                            || errorOptions.journal == true
                            || errorOptions.fsync == true
                        }
                        
                        /**
                         * @ignore
                         */
                        var _setWriteConcernHash = function(options) {
                          var finalOptions = {};
                          if(options.w != null) finalOptions.w = options.w;
                          if(options.journal == true) finalOptions.j = options.journal;
                          if(options.j == true) finalOptions.j = options.j;
                          if(options.fsync == true) finalOptions.fsync = options.fsync;
                          if(options.wtimeout != null) finalOptions.wtimeout = options.wtimeout;
                          return finalOptions;
                        }
                        
                        /**
                         * @ignore
                         */
                        var _getWriteConcern = function(self, options) {
                          // Final options
                          var finalOptions = {w:1};
                          options = options || {};
                        
                          // Local options verification
                          if(options.w != null || typeof options.j == &#x27;boolean&#x27; || typeof options.journal == &#x27;boolean&#x27; || typeof options.fsync == &#x27;boolean&#x27;) {
                            finalOptions = _setWriteConcernHash(options);
                          } else if(options.safe != null &amp;&amp; typeof options.safe == &#x27;object&#x27;) {
                            finalOptions = _setWriteConcernHash(options.safe);
                          } else if(typeof options.safe == &quot;boolean&quot;) {
                            finalOptions = {w: (options.safe ? 1 : 0)};
                          } else if(self.options.w != null || typeof self.options.j == &#x27;boolean&#x27; || typeof self.options.journal == &#x27;boolean&#x27; || typeof self.options.fsync == &#x27;boolean&#x27;) {
                            finalOptions = _setWriteConcernHash(self.options);
                          } else if(self.safe.w != null || typeof self.safe.j == &#x27;boolean&#x27; || typeof self.safe.journal == &#x27;boolean&#x27; || typeof self.safe.fsync == &#x27;boolean&#x27;) {
                            finalOptions = _setWriteConcernHash(self.safe);
                          } else if(typeof self.safe == &quot;boolean&quot;) {
                            finalOptions = {w: (self.safe ? 1 : 0)};
                          }
                        
                          // Ensure we don&#x27;t have an invalid combination of write concerns
                          if(finalOptions.w &lt; 1
                            &amp;&amp; (finalOptions.journal == true || finalOptions.j == true || finalOptions.fsync == true)) throw new Error(&quot;No acknowledgement using w &lt; 1 cannot be combined with journal:true or fsync:true&quot;);
                        
                          // Return the options
                          return finalOptions;
                        }
                        
                        /**
                         * @ignore
                         * @api private
                         */
                        exports.GridStore = GridStore;
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
