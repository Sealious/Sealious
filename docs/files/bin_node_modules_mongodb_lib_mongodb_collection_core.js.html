<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bin/node_modules/mongodb/lib/mongodb/collection/core.js - Prometheus Framework</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Prometheus Framework"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Represents a 
                Replicaset Configuration.html">Represents a 
                Replicaset Configuration</a></li>
                                <li><a href="../classes/Represents a BatchWriteResult.html">Represents a BatchWriteResult</a></li>
                                <li><a href="../classes/Represents a Collection.html">Represents a Collection</a></li>
                                <li><a href="../classes/Represents a Cursor..html">Represents a Cursor.</a></li>
                                <li><a href="../classes/Represents a CursorStream..html">Represents a CursorStream.</a></li>
                                <li><a href="../classes/Represents a Db.html">Represents a Db</a></li>
                                <li><a href="../classes/Represents a GridFS File Stream..html">Represents a GridFS File Stream.</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Represents a MongoClient.html">Represents a MongoClient</a></li>
                                <li><a href="../classes/Represents a Mongos connection with failover to backup proxies.html">Represents a Mongos connection with failover to backup proxies</a></li>
                                <li><a href="../classes/Represents a OrderedBulkOperation.html">Represents a OrderedBulkOperation</a></li>
                                <li><a href="../classes/Represents a Read Preference..html">Represents a Read Preference.</a></li>
                                <li><a href="../classes/Represents a Server connection..html">Represents a Server connection.</a></li>
                                <li><a href="../classes/Represents a UnorderedBulkOperation.html">Represents a UnorderedBulkOperation</a></li>
                                <li><a href="../classes/Represents the Admin methods of MongoDB..html">Represents the Admin methods of MongoDB.</a></li>
                                <li><a href="../classes/Represents the Grid..html">Represents the Grid.</a></li>
                                <li><a href="../classes/Represents the GridStore..html">Represents the GridStore.</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/association.html">association</a></li>
                                <li><a href="../modules/database-accessor.html">database-accessor</a></li>
                                <li><a href="../modules/field-type-manager.html">field-type-manager</a></li>
                                <li><a href="../modules/resource-type-manager.html">resource-type-manager</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: bin/node_modules/mongodb/lib/mongodb/collection/core.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        var InsertCommand = require(&#x27;../commands/insert_command&#x27;).InsertCommand
                          , DeleteCommand = require(&#x27;../commands/delete_command&#x27;).DeleteCommand
                          , UpdateCommand = require(&#x27;../commands/update_command&#x27;).UpdateCommand
                          , DbCommand = require(&#x27;../commands/db_command&#x27;).DbCommand
                          , utils = require(&#x27;../utils&#x27;)
                          , hasWriteCommands = require(&#x27;../utils&#x27;).hasWriteCommands
                          , shared = require(&#x27;./shared&#x27;);
                        
                        /**
                         * Precompiled regexes
                         * @ignore
                         **/
                        var eErrorMessages = /No matching object found/;
                        
                        // ***************************************************
                        // Insert function
                        // ***************************************************
                        var insert = function insert (docs, options, callback) {
                          if (&#x27;function&#x27; === typeof options) callback = options, options = {};
                          if(options == null) options = {};
                          if(!(&#x27;function&#x27; === typeof callback)) callback = null;
                        
                          // Get a connection
                          var connection = this.db.serverConfig.checkoutWriter();
                          var useLegacyOps = options.useLegacyOps == null || options.useLegacyOps == false ? false : true;
                          // If we support write commands let&#x27;s perform the insert using it  
                          if(!useLegacyOps &amp;&amp; hasWriteCommands(connection) 
                            &amp;&amp; !Buffer.isBuffer(docs) 
                            &amp;&amp; !(Array.isArray(docs) &amp;&amp; docs.length &gt; 0 &amp;&amp; Buffer.isBuffer(docs[0]))) {
                              insertWithWriteCommands(this, Array.isArray(docs) ? docs : [docs], options, callback);
                              return this
                          } 
                        
                          // Backwards compatibility
                          insertAll(this, Array.isArray(docs) ? docs : [docs], options, callback);
                          return this;
                        };
                        
                        //
                        // Uses the new write commands available from 2.6 &gt;
                        //
                        var insertWithWriteCommands = function(self, docs, options, callback) {
                          // Get the intended namespace for the operation
                          var namespace = self.collectionName;
                        
                          // Ensure we have no \x00 bytes in the name causing wrong parsing
                          if(!!~namespace.indexOf(&quot;\x00&quot;)) {
                            return callback(new Error(&quot;namespace cannot contain a null character&quot;), null);
                          }
                        
                          // Check if we have passed in continue on error
                          var continueOnError = typeof options[&#x27;keepGoing&#x27;] == &#x27;boolean&#x27; 
                            ? options[&#x27;keepGoing&#x27;] : false;
                          continueOnError = typeof options[&#x27;continueOnError&#x27;] == &#x27;boolean&#x27; 
                            ? options[&#x27;continueOnError&#x27;] : continueOnError;
                        
                          // Do we serialzie functions
                          var serializeFunctions = typeof options.serializeFunctions != &#x27;boolean&#x27; 
                            ? self.serializeFunctions : options.serializeFunctions;
                        
                          // Checkout a write connection
                          var connection = self.db.serverConfig.checkoutWriter();  
                        
                          // Do we return the actual result document
                          var fullResult = typeof options.fullResult == &#x27;boolean&#x27; ? options.fullResult : false;
                        
                          // Collect errorOptions
                          var errorOptions = shared._getWriteConcern(self, options);
                        
                          // If we have a write command with no callback and w:0 fail
                          if(errorOptions.w &amp;&amp; errorOptions.w != 0 &amp;&amp; callback == null) {
                            throw new Error(&quot;writeConcern requires callback&quot;)
                          }
                        
                          // Add the documents and decorate them with id&#x27;s if they have none
                          for(var index = 0, len = docs.length; index &lt; len; ++index) {
                            var doc = docs[index];
                        
                            // Add id to each document if it&#x27;s not already defined
                            if (!(Buffer.isBuffer(doc))
                              &amp;&amp; doc[&#x27;_id&#x27;] == null
                              &amp;&amp; self.db.forceServerObjectId != true
                              &amp;&amp; options.forceServerObjectId != true) {
                                doc[&#x27;_id&#x27;] = self.pkFactory.createPk();
                            }
                          }
                        
                          // Single document write
                          if(docs.length == 1) {
                            // Create the write command
                            var write_command = {
                                insert: namespace
                              , writeConcern: errorOptions
                              , ordered: !continueOnError
                              , documents: docs
                            }
                        
                            // Execute the write command
                            return self.db.command(write_command
                              , { connection:connection
                                , checkKeys: typeof options.checkKeys == &#x27;boolean&#x27; ? options.checkKeys : true
                                , serializeFunctions: serializeFunctions
                                , writeCommand: true }
                              , function(err, result) {  
                                if(errorOptions.w == 0 &amp;&amp; typeof callback == &#x27;function&#x27;) return callback(null, null);
                                if(errorOptions.w == 0) return;
                                if(callback == null) return;
                                if(err != null) {
                                  return callback(err, null);
                                }
                        
                                // Result has an error
                                if(!result.ok || Array.isArray(result.writeErrors) &amp;&amp; result.writeErrors.length &gt; 0) {
                                  var error = utils.toError(result.writeErrors[0].errmsg);
                                  error.code = result.writeErrors[0].code;
                                  error.err = result.writeErrors[0].errmsg;
                                  
                                  if (fullResult) return callback(error, result != null ? result.getRawResponse() : null);
                                  // Return the error
                                  return callback(error, null);
                                }
                        
                                if(fullResult) return callback(null, result);
                                // Return the results for a whole batch
                                callback(null, docs)
                            });    
                          } else {
                            try {
                              // Multiple document write (use bulk)
                              var bulk = !continueOnError ? self.initializeOrderedBulkOp() : self.initializeUnorderedBulkOp();
                              // Add all the documents
                              for(var i = 0; i &lt; docs.length;i++) {
                                bulk.insert(docs[i]);
                              }
                        
                              // Execute the command
                              bulk.execute(errorOptions, function(err, result) {
                                if(errorOptions.w == 0 &amp;&amp; typeof callback == &#x27;function&#x27;) return callback(null, null);
                                if(errorOptions.w == 0) return;
                                if(callback == null) return;
                                if(err) return callback(err, null);
                                if(result.hasWriteErrors()) {
                                  var error = result.getWriteErrors()[0];
                                  error.code = result.getWriteErrors()[0].code;
                                  error.err = result.getWriteErrors()[0].errmsg;        
                                  
                                  if (fullResult) return callback(error, result != null ? result.getRawResponse() : null);
                                  // Return the error
                                  return callback(error, null);
                                }
                        
                                if(fullResult) return callback(null, result != null ? result.getRawResponse() : null);
                                // Return the results for a whole batch
                                callback(null, docs)
                              });
                            } catch(err) {
                              callback(utils.toError(err), null);
                            }
                          }
                        }
                        
                        //
                        // Uses pre 2.6 OP_INSERT wire protocol
                        //
                        var insertAll = function insertAll (self, docs, options, callback) {
                          if(&#x27;function&#x27; === typeof options) callback = options, options = {};
                          if(options == null) options = {};
                          if(!(&#x27;function&#x27; === typeof callback)) callback = null;
                        
                          // Insert options (flags for insert)
                          var insertFlags = {};
                          // If we have a mongodb version &gt;= 1.9.1 support keepGoing attribute
                          if(options[&#x27;keepGoing&#x27;] != null) {
                            insertFlags[&#x27;keepGoing&#x27;] = options[&#x27;keepGoing&#x27;];
                          }
                        
                          // If we have a mongodb version &gt;= 1.9.1 support keepGoing attribute
                          if(options[&#x27;continueOnError&#x27;] != null) {
                            insertFlags[&#x27;continueOnError&#x27;] = options[&#x27;continueOnError&#x27;];
                          }
                        
                          // DbName
                          var dbName = options[&#x27;dbName&#x27;];
                          // If no dbname defined use the db one
                          if(dbName == null) {
                            dbName = self.db.databaseName;
                          }
                        
                          // Either use override on the function, or go back to default on either the collection
                          // level or db
                          if(options[&#x27;serializeFunctions&#x27;] != null) {
                            insertFlags[&#x27;serializeFunctions&#x27;] = options[&#x27;serializeFunctions&#x27;];
                          } else {
                            insertFlags[&#x27;serializeFunctions&#x27;] = self.serializeFunctions;
                          }
                        
                          // Get checkKeys value
                          var checkKeys = typeof options.checkKeys != &#x27;boolean&#x27; ? true : options.checkKeys;
                        
                          // Do we return the actual result document
                          var fullResult = typeof options.fullResult == &#x27;boolean&#x27; ? options.fullResult : false;
                        
                          // Pass in options
                          var insertCommand = new InsertCommand(
                              self.db
                            , dbName + &quot;.&quot; + self.collectionName, checkKeys, insertFlags);
                        
                          // Add the documents and decorate them with id&#x27;s if they have none
                          for(var index = 0, len = docs.length; index &lt; len; ++index) {
                            var doc = docs[index];
                        
                            // Add id to each document if it&#x27;s not already defined
                            if (!(Buffer.isBuffer(doc))
                              &amp;&amp; doc[&#x27;_id&#x27;] == null
                              &amp;&amp; self.db.forceServerObjectId != true
                              &amp;&amp; options.forceServerObjectId != true) {
                                doc[&#x27;_id&#x27;] = self.pkFactory.createPk();
                            }
                        
                            insertCommand.add(doc);
                          }
                        
                          // Collect errorOptions
                          var errorOptions = shared._getWriteConcern(self, options);
                          // Default command options
                          var commandOptions = {};
                          // If safe is defined check for error message
                          if(shared._hasWriteConcern(errorOptions) &amp;&amp; typeof callback == &#x27;function&#x27;) {
                            // Set safe option
                            commandOptions[&#x27;safe&#x27;] = errorOptions;
                            // If we have an error option
                            if(typeof errorOptions == &#x27;object&#x27;) {
                              var keys = Object.keys(errorOptions);
                              for(var i = 0; i &lt; keys.length; i++) {
                                commandOptions[keys[i]] = errorOptions[keys[i]];
                              }
                            }
                        
                            // If we have a passed in connection use it
                            if(options.connection) {
                              commandOptions.connection = options.connection;
                            }
                        
                            // Execute command with safe options (rolls up both command and safe command into one and executes them on the same connection)
                            self.db._executeInsertCommand(insertCommand, commandOptions, handleWriteResults(function (err, results) {
                              if(err) return callback(err, null);
                              if(results == null) return callback(new Error(&quot;command failed to return result&quot;));
                              if(fullResult) return callback(null, results);
                              callback(null, docs);
                            }));
                          } else if(shared._hasWriteConcern(errorOptions) &amp;&amp; callback == null) {
                            throw new Error(&quot;Cannot use a writeConcern without a provided callback&quot;);
                          } else {
                            // Execute the call without a write concern
                            var result = self.db._executeInsertCommand(insertCommand, commandOptions);
                            // If no callback just return
                            if(!callback) return;
                            // If error return error
                            if(result instanceof Error) {
                              return callback(result);
                            }
                        
                            // Otherwise just return
                            return callback(null, docs);
                          }
                        };
                        
                        // ***************************************************
                        // Remove function
                        // ***************************************************
                        var removeWithWriteCommands = function(self, selector, options, callback) {
                          if(&#x27;function&#x27; === typeof selector) {
                            callback = selector;
                            selector = options = {};
                          } else if (&#x27;function&#x27; === typeof options) {
                            callback = options;
                            options = {};
                          }
                        
                          // Get the intended namespace for the operation
                          var namespace = self.collectionName;
                        
                          // Ensure we have no \x00 bytes in the name causing wrong parsing
                          if(!!~namespace.indexOf(&quot;\x00&quot;)) {
                            return callback(new Error(&quot;namespace cannot contain a null character&quot;), null);
                          }
                        
                          // Set default empty selector if none
                          selector = selector == null ? {} : selector;
                        
                          // Check if we have passed in continue on error
                          var continueOnError = typeof options[&#x27;keepGoing&#x27;] == &#x27;boolean&#x27; 
                            ? options[&#x27;keepGoing&#x27;] : false;
                          continueOnError = typeof options[&#x27;continueOnError&#x27;] == &#x27;boolean&#x27; 
                            ? options[&#x27;continueOnError&#x27;] : continueOnError;
                        
                          // Do we serialzie functions
                          var serializeFunctions = typeof options.serializeFunctions != &#x27;boolean&#x27; 
                            ? self.serializeFunctions : options.serializeFunctions;
                        
                          // Checkout a write connection
                          var connection = self.db.serverConfig.checkoutWriter();  
                        
                          // Figure out the value of top
                          var limit = options.single == true ? 1 : 0;
                          var upsert = typeof options.upsert == &#x27;boolean&#x27; ? options.upsert : false;
                        
                          // Do we return the actual result document
                          var fullResult = typeof options.fullResult == &#x27;boolean&#x27; ? options.fullResult : false;
                        
                          // Collect errorOptions
                          var errorOptions = shared._getWriteConcern(self, options);
                        
                          // If we have a write command with no callback and w:0 fail
                          if(errorOptions.w &amp;&amp; errorOptions.w != 0 &amp;&amp; callback == null) {
                            throw new Error(&quot;writeConcern requires callback&quot;)
                          }
                        
                          // Create the write command
                          var write_command = {
                            delete: namespace,
                            writeConcern: errorOptions,
                            ordered: !continueOnError,
                            deletes: [{
                              q : selector,
                              limit: limit
                            }]
                          }
                        
                          // Execute the write command
                          self.db.command(write_command
                            , { connection:connection
                              , checkKeys: false
                              , serializeFunctions: serializeFunctions
                              , writeCommand: true }
                            , function(err, result) {  
                              if(errorOptions.w == 0 &amp;&amp; typeof callback == &#x27;function&#x27;) return callback(null, null);
                              if(errorOptions.w == 0) return;
                              if(callback == null) return;
                              if(err != null) {
                                return callback(err, null);
                              }
                        
                              // Result has an error
                              if(!result.ok || Array.isArray(result.writeErrors) &amp;&amp; result.writeErrors.length &gt; 0) {
                                var error = utils.toError(result.writeErrors[0].errmsg);
                                error.code = result.writeErrors[0].code;
                                error.err = result.writeErrors[0].errmsg;
                                // Return the error
                                return callback(error, null);
                              }
                              
                              if(fullResult) return callback(null, result);
                              // Backward compatibility format
                              var r = backWardsCompatibiltyResults(result, &#x27;remove&#x27;);      
                              // Return the results for a whole batch
                              callback(null, r.n, r)
                          });
                        }
                        
                        var remove = function remove(selector, options, callback) {
                          if(&#x27;function&#x27; === typeof options) callback = options, options = null;
                          if(options == null) options = {};
                          if(!(&#x27;function&#x27; === typeof callback)) callback = null;
                        
                          // Get a connection
                          var connection = this.db.serverConfig.checkoutWriter();
                          var useLegacyOps = options.useLegacyOps == null || options.useLegacyOps == false ? false : true;
                        
                          // If we support write commands let&#x27;s perform the insert using it  
                          if(!useLegacyOps &amp;&amp; hasWriteCommands(connection) &amp;&amp; !Buffer.isBuffer(selector)) {
                            return removeWithWriteCommands(this, selector, options, callback);
                          }
                        
                          if (&#x27;function&#x27; === typeof selector) {
                            callback = selector;
                            selector = options = {};
                          } else if (&#x27;function&#x27; === typeof options) {
                            callback = options;
                            options = {};
                          }
                        
                          // Ensure options
                          if(options == null) options = {};
                          if(!(&#x27;function&#x27; === typeof callback)) callback = null;
                          // Ensure we have at least an empty selector
                          selector = selector == null ? {} : selector;
                          // Set up flags for the command, if we have a single document remove
                          var flags = 0 | (options.single ? 1 : 0);
                        
                          // Do we return the actual result document
                          var fullResult = typeof options.fullResult == &#x27;boolean&#x27; ? options.fullResult : false;
                        
                          // DbName
                          var dbName = options[&#x27;dbName&#x27;];
                          // If no dbname defined use the db one
                          if(dbName == null) {
                            dbName = this.db.databaseName;
                          }
                        
                          // Create a delete command
                          var deleteCommand = new DeleteCommand(
                              this.db
                            , dbName + &quot;.&quot; + this.collectionName
                            , selector
                            , flags);
                        
                          var self = this;
                          var errorOptions = shared._getWriteConcern(self, options);
                        
                          // Execute the command, do not add a callback as it&#x27;s async
                          if(shared._hasWriteConcern(errorOptions) &amp;&amp; typeof callback == &#x27;function&#x27;) {
                            // Insert options
                            var commandOptions = {};
                            // Set safe option
                            commandOptions[&#x27;safe&#x27;] = true;
                            // If we have an error option
                            if(typeof errorOptions == &#x27;object&#x27;) {
                              var keys = Object.keys(errorOptions);
                              for(var i = 0; i &lt; keys.length; i++) {
                                commandOptions[keys[i]] = errorOptions[keys[i]];
                              }
                            }
                        
                            // If we have a passed in connection use it
                            if(options.connection) {
                              commandOptions.connection = options.connection;
                            }
                        
                            // Execute command with safe options (rolls up both command and safe command into one and executes them on the same connection)
                            this.db._executeRemoveCommand(deleteCommand, commandOptions, handleWriteResults(function (err, results) {
                              if(err) return callback(err, null);
                              if(results == null) return callback(new Error(&quot;command failed to return result&quot;));
                              if(fullResult) return callback(null, results);
                              callback(null, results[0].n);
                            }));
                          } else if(shared._hasWriteConcern(errorOptions) &amp;&amp; callback == null) {
                            throw new Error(&quot;Cannot use a writeConcern without a provided callback&quot;);
                          } else {
                            var result = this.db._executeRemoveCommand(deleteCommand);
                            // If no callback just return
                            if (!callback) return;
                            // If error return error
                            if (result instanceof Error) {
                              return callback(result);
                            }
                            // Otherwise just return
                            return callback();
                          }
                        };
                        
                        // ***************************************************
                        // Save function
                        // ***************************************************
                        var save = function save(doc, options, callback) {
                          if(&#x27;function&#x27; === typeof options) callback = options, options = null;
                          if(options == null) options = {};
                          if(!(&#x27;function&#x27; === typeof callback)) callback = null;
                          // Throw an error if attempting to perform a bulk operation
                          if(Array.isArray(doc)) throw new Error(&quot;doc parameter must be a single document&quot;);
                          // Extract the id, if we have one we need to do a update command
                          var id = doc[&#x27;_id&#x27;];
                          var commandOptions = shared._getWriteConcern(this, options);
                          if(options.connection) commandOptions.connection = options.connection;
                          if(typeof options.fullResult == &#x27;boolean&#x27;) commandOptions.fullResult = options.fullResult;
                        
                          if(id != null) {
                            commandOptions.upsert = true;
                            this.update({ _id: id }, doc, commandOptions, callback);
                          } else {
                            this.insert(doc, commandOptions, callback &amp;&amp; function (err, docs) {
                              if(err) return callback(err, null);
                        
                              if(Array.isArray(docs)) {
                                callback(err, docs[0]);
                              } else {
                                callback(err, docs);
                              }
                            });
                          }
                        };
                        
                        // ***************************************************
                        // Update document function
                        // ***************************************************
                        var updateWithWriteCommands = function(self, selector, document, options, callback) {
                          if(&#x27;function&#x27; === typeof options) callback = options, options = null;
                          if(options == null) options = {};
                          if(!(&#x27;function&#x27; === typeof callback)) callback = null;
                        
                          // Get the intended namespace for the operation
                          var namespace = self.collectionName;
                        
                          // Ensure we have no \x00 bytes in the name causing wrong parsing
                          if(!!~namespace.indexOf(&quot;\x00&quot;)) {
                            return callback(new Error(&quot;namespace cannot contain a null character&quot;), null);
                          }
                        
                          // If we are not providing a selector or document throw
                          if(selector == null || typeof selector != &#x27;object&#x27;) 
                            return callback(new Error(&quot;selector must be a valid JavaScript object&quot;));
                          if(document == null || typeof document != &#x27;object&#x27;) 
                            return callback(new Error(&quot;document must be a valid JavaScript object&quot;));    
                        
                          // Check if we have passed in continue on error
                          var continueOnError = typeof options[&#x27;keepGoing&#x27;] == &#x27;boolean&#x27; 
                            ? options[&#x27;keepGoing&#x27;] : false;
                          continueOnError = typeof options[&#x27;continueOnError&#x27;] == &#x27;boolean&#x27; 
                            ? options[&#x27;continueOnError&#x27;] : continueOnError;
                        
                          // Do we serialzie functions
                          var serializeFunctions = typeof options.serializeFunctions != &#x27;boolean&#x27; 
                            ? self.serializeFunctions : options.serializeFunctions;
                        
                          // Checkout a write connection
                          var connection = self.db.serverConfig.checkoutWriter();  
                        
                          // Figure out the value of top
                          var multi = typeof options.multi == &#x27;boolean&#x27; ? options.multi : false;
                          var upsert = typeof options.upsert == &#x27;boolean&#x27; ? options.upsert : false;
                        
                          // Do we return the actual result document
                          var fullResult = typeof options.fullResult == &#x27;boolean&#x27; ? options.fullResult : false;
                        
                          // Collect errorOptions
                          var errorOptions = shared._getWriteConcern(self, options);
                        
                          // If we have a write command with no callback and w:0 fail
                          if(errorOptions.w &amp;&amp; errorOptions.w != 0 &amp;&amp; callback == null) {
                            throw new Error(&quot;writeConcern requires callback&quot;)
                          }
                        
                          // Create the write command
                          var write_command = {
                            update: namespace,
                            writeConcern: errorOptions,
                            ordered: !continueOnError,
                            updates: [{
                              q : selector,
                              u: document,
                              multi: multi,
                              upsert: upsert
                            }]
                          }
                        
                          // Check if we have a checkKeys override
                          var checkKeys = typeof options.checkKeys == &#x27;boolean&#x27; ? options.checkKeys : false;
                        
                          // Execute the write command
                          self.db.command(write_command
                            , { connection:connection
                              , checkKeys: checkKeys
                              , serializeFunctions: serializeFunctions
                              , writeCommand: true }
                            , function(err, result) { 
                              if(errorOptions.w == 0 &amp;&amp; typeof callback == &#x27;function&#x27;) return callback(null, null);
                              if(errorOptions.w == 0) return;
                              if(callback == null) return;
                        
                              if(errorOptions.w == 0 &amp;&amp; typeof callback == &#x27;function&#x27;) return callback(null, null);
                              if(errorOptions.w == 0) return;
                              if(callback == null) return;
                              if(err != null) {
                                return callback(err, null);
                              }
                        
                              // Result has an error
                              if(!result.ok || Array.isArray(result.writeErrors) &amp;&amp; result.writeErrors.length &gt; 0) {
                                var error = utils.toError(result.writeErrors[0].errmsg);
                                error.code = result.writeErrors[0].code;
                                error.err = result.writeErrors[0].errmsg;        
                                return callback(error, null);
                              }
                              
                              if(fullResult) return callback(null, result);
                              // Backward compatibility format
                              var r = backWardsCompatibiltyResults(result, &#x27;update&#x27;);
                              // Return the results for a whole batch
                              callback(null, r.n, r)
                          });
                        }
                        
                        var backWardsCompatibiltyResults = function(result, op) {
                          // Upserted
                          var upsertedValue = null;
                          var finalResult = null;
                          var updatedExisting = true;
                        
                          // We have a single document upserted result
                          if(Array.isArray(result.upserted) || result.upserted != null) {
                            updatedExisting = false;
                            upsertedValue = result.upserted;
                          }
                        
                          // Final result
                          if(op == &#x27;remove&#x27; || op == &#x27;insert&#x27;) {
                            finalResult = {ok: true, n: result.n}
                          } else {
                            finalResult = {ok: true, n: result.n, updatedExisting: updatedExisting}
                          }
                        
                          if(upsertedValue != null) finalResult.upserted = upsertedValue;
                          return finalResult;
                        }
                        
                        var handleWriteResults = function handleWriteResults(callback) {
                          return function(err, error) {
                            var documents = error &amp;&amp; error.documents;
                            if(!callback) return;
                            // We have an error
                            if(err) return callback(err, null);
                            // If no document something is terribly wrong
                            if(error == null) return callback(utils.toError(&quot;MongoDB did not return a response&quot;));
                            // Handle the case where no result was returned
                            if(error != null &amp;&amp; documents == null) {
                              if(typeof error.err == &#x27;string&#x27;) {
                                return callback(utils.toError(error.err));  
                              } else if(typeof error.errmsg == &#x27;string&#x27;) {
                                return callback(utils.toError(error.errmsg));          
                              } else {
                                return callback(utils.toError(&quot;Unknown MongoDB error&quot;));
                              }
                            }
                        
                            // Handler normal cases
                            if(documents[0].err || documents[0].errmsg) {
                              callback(utils.toError(documents[0]));
                            } else if(documents[0].jnote || documents[0].wtimeout) {
                              callback(utils.toError(documents[0]));
                            } else {
                              callback(err, documents);
                            }
                          }
                        }
                        
                        var update = function update(selector, document, options, callback) {
                          if(&#x27;function&#x27; === typeof options) callback = options, options = null;
                          if(options == null) options = {};
                          if(!(&#x27;function&#x27; === typeof callback)) callback = null;
                        
                          // Get a connection
                          var connection = options.connection || this.db.serverConfig.checkoutWriter();
                          var useLegacyOps = options.useLegacyOps == null || options.useLegacyOps == false ? false : true;
                          // If we support write commands let&#x27;s perform the insert using it  
                          if(!useLegacyOps &amp;&amp; hasWriteCommands(connection) &amp;&amp; !Buffer.isBuffer(selector) &amp;&amp; !Buffer.isBuffer(document)) {
                            return updateWithWriteCommands(this, selector, document, options, callback);
                          }
                        
                          // DbName
                          var dbName = options[&#x27;dbName&#x27;];
                          // If no dbname defined use the db one
                          if(dbName == null) {
                            dbName = this.db.databaseName;
                          }
                        
                          // If we are not providing a selector or document throw
                          if(selector == null || typeof selector != &#x27;object&#x27;) return callback(new Error(&quot;selector must be a valid JavaScript object&quot;));
                          if(document == null || typeof document != &#x27;object&#x27;) return callback(new Error(&quot;document must be a valid JavaScript object&quot;));
                        
                          // Do we return the actual result document
                          var fullResult = typeof options.fullResult == &#x27;boolean&#x27; ? options.fullResult : false;
                        
                          // Either use override on the function, or go back to default on either the collection
                          // level or db
                          if(options[&#x27;serializeFunctions&#x27;] != null) {
                            options[&#x27;serializeFunctions&#x27;] = options[&#x27;serializeFunctions&#x27;];
                          } else {
                            options[&#x27;serializeFunctions&#x27;] = this.serializeFunctions;
                          }
                        
                          // Build the options command
                          var updateCommand = new UpdateCommand(
                              this.db
                            , dbName + &quot;.&quot; + this.collectionName
                            , selector
                            , document
                            , options);
                        
                          var self = this;
                          // Unpack the error options if any
                          var errorOptions = shared._getWriteConcern(this, options);
                          // If safe is defined check for error message
                          if(shared._hasWriteConcern(errorOptions) &amp;&amp; typeof callback == &#x27;function&#x27;) {
                            // Insert options
                            var commandOptions = {};
                            // Set safe option
                            commandOptions[&#x27;safe&#x27;] = errorOptions;
                            // If we have an error option
                            if(typeof errorOptions == &#x27;object&#x27;) {
                              var keys = Object.keys(errorOptions);
                              for(var i = 0; i &lt; keys.length; i++) {
                                commandOptions[keys[i]] = errorOptions[keys[i]];
                              }
                            }
                        
                            // If we have a passed in connection use it
                            if(options.connection) {
                              commandOptions.connection = options.connection;
                            }
                        
                            // Execute command with safe options (rolls up both command and safe command into one and executes them on the same connection)
                            this.db._executeUpdateCommand(updateCommand, commandOptions, handleWriteResults(function(err, results) {
                              if(err) return callback(err, null);
                              if(results == null) return callback(new Error(&quot;command failed to return result&quot;));
                              if(fullResult) return callback(null, results);
                              callback(null, results[0].n, results[0]);
                            }));
                          } else if(shared._hasWriteConcern(errorOptions) &amp;&amp; callback == null) {
                            throw new Error(&quot;Cannot use a writeConcern without a provided callback&quot;);
                          } else {
                            // Execute update
                            var result = this.db._executeUpdateCommand(updateCommand);
                            // If no callback just return
                            if (!callback) return;
                            // If error return error
                            if (result instanceof Error) {
                              return callback(result);
                            }
                            
                            // Otherwise just return
                            return callback();
                          }
                        };
                        
                        // ***************************************************
                        // findAndModify function
                        // ***************************************************
                        var findAndModify = function findAndModify (query, sort, doc, options, callback) {
                          var args = Array.prototype.slice.call(arguments, 1);
                          callback = args.pop();
                          sort = args.length ? args.shift() || [] : [];
                          doc = args.length ? args.shift() : null;
                          options = args.length ? args.shift() || {} : {};
                          var self = this;
                        
                          var queryObject = {
                             &#x27;findandmodify&#x27;: this.collectionName
                           , &#x27;query&#x27;: query
                          };
                        
                          sort = utils.formattedOrderClause(sort);
                          if (sort) {
                            queryObject.sort = sort;
                          }
                        
                          queryObject.new = options.new ? 1 : 0;
                          queryObject.remove = options.remove ? 1 : 0;
                          queryObject.upsert = options.upsert ? 1 : 0;
                        
                          if (options.fields) {
                            queryObject.fields = options.fields;
                          }
                        
                          if (doc &amp;&amp; !options.remove) {
                            queryObject.update = doc;
                          }
                        
                          // Checkout a write connection
                          options.connection = self.db.serverConfig.checkoutWriter();  
                        
                          // Either use override on the function, or go back to default on either the collection
                          // level or db
                          if(options[&#x27;serializeFunctions&#x27;] != null) {
                            options[&#x27;serializeFunctions&#x27;] = options[&#x27;serializeFunctions&#x27;];
                          } else {
                            options[&#x27;serializeFunctions&#x27;] = this.serializeFunctions;
                          }
                        
                          // No check on the documents
                          options.checkKeys = false;
                        
                          // Execute the command
                          this.db.command(queryObject
                            , options, function(err, result) {
                              if(err) return callback(err, null);
                              return callback(null, result.value, result);
                          });
                        }
                        
                        // ***************************************************
                        // findAndRemove function
                        // ***************************************************
                        var findAndRemove = function(query, sort, options, callback) {
                          var args = Array.prototype.slice.call(arguments, 1);
                          callback = args.pop();
                          sort = args.length ? args.shift() || [] : [];
                          options = args.length ? args.shift() || {} : {};
                          // Add the remove option
                          options[&#x27;remove&#x27;] = true;
                          // Execute the callback
                          this.findAndModify(query, sort, null, options, callback);
                        }
                        
                        // Map methods
                        exports.insert = insert;
                        exports.remove = remove;
                        exports.save = save;
                        exports.update = update;
                        exports.findAndModify = findAndModify;
                        exports.findAndRemove = findAndRemove;
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
