<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bin/node_modules/mongodb/lib/mongodb/connection/server.js - Prometheus Framework</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Prometheus Framework"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Represents a 
                Replicaset Configuration.html">Represents a 
                Replicaset Configuration</a></li>
                                <li><a href="../classes/Represents a BatchWriteResult.html">Represents a BatchWriteResult</a></li>
                                <li><a href="../classes/Represents a Collection.html">Represents a Collection</a></li>
                                <li><a href="../classes/Represents a Cursor..html">Represents a Cursor.</a></li>
                                <li><a href="../classes/Represents a CursorStream..html">Represents a CursorStream.</a></li>
                                <li><a href="../classes/Represents a Db.html">Represents a Db</a></li>
                                <li><a href="../classes/Represents a GridFS File Stream..html">Represents a GridFS File Stream.</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Represents a MongoClient.html">Represents a MongoClient</a></li>
                                <li><a href="../classes/Represents a Mongos connection with failover to backup proxies.html">Represents a Mongos connection with failover to backup proxies</a></li>
                                <li><a href="../classes/Represents a OrderedBulkOperation.html">Represents a OrderedBulkOperation</a></li>
                                <li><a href="../classes/Represents a Read Preference..html">Represents a Read Preference.</a></li>
                                <li><a href="../classes/Represents a Server connection..html">Represents a Server connection.</a></li>
                                <li><a href="../classes/Represents a UnorderedBulkOperation.html">Represents a UnorderedBulkOperation</a></li>
                                <li><a href="../classes/Represents the Admin methods of MongoDB..html">Represents the Admin methods of MongoDB.</a></li>
                                <li><a href="../classes/Represents the Grid..html">Represents the Grid.</a></li>
                                <li><a href="../classes/Represents the GridStore..html">Represents the GridStore.</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/association.html">association</a></li>
                                <li><a href="../modules/database-accessor.html">database-accessor</a></li>
                                <li><a href="../modules/field-type-manager.html">field-type-manager</a></li>
                                <li><a href="../modules/resource-type-manager.html">resource-type-manager</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: bin/node_modules/mongodb/lib/mongodb/connection/server.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        var Connection = require(&#x27;./connection&#x27;).Connection,
                          ReadPreference = require(&#x27;./read_preference&#x27;).ReadPreference,
                          DbCommand = require(&#x27;../commands/db_command&#x27;).DbCommand,
                          MongoReply = require(&#x27;../responses/mongo_reply&#x27;).MongoReply,
                          ConnectionPool = require(&#x27;./connection_pool&#x27;).ConnectionPool,
                          EventEmitter = require(&#x27;events&#x27;).EventEmitter,
                          ServerCapabilities = require(&#x27;./server_capabilities&#x27;).ServerCapabilities,
                          Base = require(&#x27;./base&#x27;).Base,
                          format = require(&#x27;util&#x27;).format,
                          utils = require(&#x27;../utils&#x27;),
                          timers = require(&#x27;timers&#x27;),
                          inherits = require(&#x27;util&#x27;).inherits;
                        
                        // Set processor, setImmediate if 0.10 otherwise nextTick
                        var processor = require(&#x27;../utils&#x27;).processor();
                        
                        /**
                         * Class representing a single MongoDB Server connection
                         *
                         * Options
                         *  - **ssl** {Boolean, default:false}, use ssl connection (needs to have a mongod server with ssl support)
                         *  - **sslValidate** {Boolean, default:false}, validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
                         *  - **sslCA** {Array, default:null}, Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
                         *  - **sslCert** {Buffer/String, default:null}, String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
                         *  - **sslKey** {Buffer/String, default:null}, String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
                         *  - **sslPass** {Buffer/String, default:null}, String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
                         *  - **poolSize** {Number, default:5}, number of connections in the connection pool, set to 5 as default for legacy reasons.
                         *  - **socketOptions** {Object, default:null}, an object containing socket options to use (noDelay:(boolean), keepAlive:(number), connectTimeoutMS:(number), socketTimeoutMS:(number))
                         *  - **logger** {Object, default:null}, an object representing a logger that you want to use, needs to support functions debug, log, error **({error:function(message, object) {}, log:function(message, object) {}, debug:function(message, object) {}})**.
                         *  - **auto_reconnect** {Boolean, default:false}, reconnect on error.
                         *  - **disableDriverBSONSizeCheck** {Boolean, default:false}, force the server to error if the BSON message is to big
                         *
                         * @class Represents a Server connection.
                         * @param {String} host the server host
                         * @param {Number} port the server port
                         * @param {Object} [options] optional options for insert command
                         */
                        function Server(host, port, options) {
                          // Set up Server instance
                          if(!(this instanceof Server)) return new Server(host, port, options);
                        
                          // Set up event emitter
                          Base.call(this);
                        
                          // Ensure correct values
                          if(port != null &amp;&amp; typeof port == &#x27;object&#x27;) {
                            options = port;
                            port = Connection.DEFAULT_PORT;
                          }
                        
                          var self = this;
                          this.host = host;
                          this.port = port;
                          this.options = options == null ? {} : options;
                          this.internalConnection;
                          this.internalMaster = false;
                          this.connected = false;  
                          this.poolSize = this.options.poolSize == null ? 5 : this.options.poolSize;
                          this.disableDriverBSONSizeCheck = this.options.disableDriverBSONSizeCheck != null ? this.options.disableDriverBSONSizeCheck : false;
                          this._used = false;
                          this.replicasetInstance = null;
                        
                          // Emit open setup
                          this.emitOpen = this.options.emitOpen || true;
                          // Set ssl as connection method
                          this.ssl = this.options.ssl == null ? false : this.options.ssl;
                          // Set ssl validation
                          this.sslValidate = this.options.sslValidate == null ? false : this.options.sslValidate;
                          // Set the ssl certificate authority (array of Buffer/String keys)
                          this.sslCA = Array.isArray(this.options.sslCA) ? this.options.sslCA : null;
                          // Certificate to present to the server
                          this.sslCert = this.options.sslCert;
                          // Certificate private key if in separate file
                          this.sslKey = this.options.sslKey;
                          // Password to unlock private key
                          this.sslPass = this.options.sslPass;
                          // Server capabilities
                          this.serverCapabilities = null;
                          // Set server name
                          this.name = format(&quot;%s:%s&quot;, host, port);
                        
                          // Ensure we are not trying to validate with no list of certificates
                          if(this.sslValidate &amp;&amp; (!Array.isArray(this.sslCA) || this.sslCA.length == 0)) {
                            throw new Error(&quot;The driver expects an Array of CA certificates in the sslCA parameter when enabling sslValidate&quot;);
                          }
                        
                          // Contains the isMaster information returned from the server
                          this.isMasterDoc;
                        
                          // Set default connection pool options
                          this.socketOptions = this.options.socketOptions != null ? this.options.socketOptions : {};
                          if(this.disableDriverBSONSizeCheck) this.socketOptions.disableDriverBSONSizeCheck = this.disableDriverBSONSizeCheck;
                        
                          // Set ssl up if it&#x27;s defined
                          if(this.ssl) {
                            this.socketOptions.ssl = true;
                            // Set ssl validation
                            this.socketOptions.sslValidate = this.sslValidate == null ? false : this.sslValidate;
                            // Set the ssl certificate authority (array of Buffer/String keys)
                            this.socketOptions.sslCA = Array.isArray(this.sslCA) ? this.sslCA : null;
                            // Set certificate to present
                            this.socketOptions.sslCert = this.sslCert;
                            // Set certificate to present
                            this.socketOptions.sslKey = this.sslKey;
                            // Password to unlock private key
                            this.socketOptions.sslPass = this.sslPass;
                          }
                        
                          // Set up logger if any set
                          this.logger = this.options.logger != null
                            &amp;&amp; (typeof this.options.logger.debug == &#x27;function&#x27;)
                            &amp;&amp; (typeof this.options.logger.error == &#x27;function&#x27;)
                            &amp;&amp; (typeof this.options.logger.log == &#x27;function&#x27;)
                              ? this.options.logger : {error:function(message, object) {}, log:function(message, object) {}, debug:function(message, object) {}};
                        
                          // Just keeps list of events we allow
                          this.eventHandlers = {error:[], parseError:[], poolReady:[], message:[], close:[], timeout:[]};
                          // Internal state of server connection
                          this._serverState = &#x27;disconnected&#x27;;
                          // Contains state information about server connection
                          this._state = {&#x27;runtimeStats&#x27;: {&#x27;queryStats&#x27;:new RunningStats()}};
                          // Do we record server stats or not
                          this.recordQueryStats = false;
                        
                          // Allow setting the socketTimeoutMS on all connections
                          // to work around issues such as secondaries blocking due to compaction
                          utils.setSocketTimeoutProperty(this, this.socketOptions);
                        };
                        
                        /**
                         * @ignore
                         */
                        inherits(Server, Base);
                        
                        //
                        //  Deprecated, USE ReadPreferences class
                        //
                        Server.READ_PRIMARY = ReadPreference.PRIMARY;
                        Server.READ_SECONDARY = ReadPreference.SECONDARY_PREFERRED;
                        Server.READ_SECONDARY_ONLY = ReadPreference.SECONDARY;
                        
                        /**
                         * Always ourselves
                         * @ignore
                         */
                        Server.prototype.setReadPreference = function(readPreference) {
                          this._readPreference = readPreference;  
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype.isMongos = function() {
                          return this.isMasterDoc != null &amp;&amp; this.isMasterDoc[&#x27;msg&#x27;] == &quot;isdbgrid&quot; ? true : false;
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype._isUsed = function() {
                          return this._used;
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype.close = function(callback) {
                          // Set server status as disconnected
                          this._serverState = &#x27;destroyed&#x27;;
                          // Remove all local listeners
                          this.removeAllListeners();
                        
                          if(this.connectionPool != null) {
                            // Remove all the listeners on the pool so it does not fire messages all over the place
                            this.connectionPool.removeAllEventListeners();
                            // Close the connection if it&#x27;s open
                            this.connectionPool.stop(true);
                          }
                        
                          // Emit close event
                          if(this.db &amp;&amp; !this.isSetMember()) {
                            var self = this;
                            processor(function() {
                              self._emitAcrossAllDbInstances(self, null, &quot;close&quot;, null, null, true)
                            })
                        
                            // Flush out any remaining call handlers
                            self._flushAllCallHandlers(utils.toError(&quot;Connection Closed By Application&quot;));
                          }
                        
                          // Peform callback if present
                          if(typeof callback === &#x27;function&#x27;) callback(null);
                        };
                        
                        Server.prototype.isDestroyed = function() {
                          return this._serverState == &#x27;destroyed&#x27;;
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype.isConnected = function() {
                          return this.connectionPool != null &amp;&amp; this.connectionPool.isConnected();
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype.canWrite = Server.prototype.isConnected;
                        Server.prototype.canRead = Server.prototype.isConnected;
                        
                        Server.prototype.isAutoReconnect = function() {
                          if(this.isSetMember()) return false;
                          return this.options.auto_reconnect != null ? this.options.auto_reconnect : true;
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype.allServerInstances = function() {
                          return [this];
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype.isSetMember = function() {
                          return this.replicasetInstance != null || this.mongosInstance != null;
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype.setSocketOptions = function(options) {
                          var connections = this.allRawConnections();
                          for(var i = 0; i &lt; connections.length; i++) {
                            connections[i].setSocketOptions(options);
                          }
                        }
                        
                        /**
                         * Assigns a replica set to this &#x60;server&#x60;.
                         *
                         * @param {ReplSet} replset
                         * @ignore
                         */
                        Server.prototype.assignReplicaSet = function (replset) {
                          this.replicasetInstance = replset;
                          this.inheritReplSetOptionsFrom(replset);
                          this.enableRecordQueryStats(replset.recordQueryStats);
                        }
                        
                        /**
                         * Takes needed options from &#x60;replset&#x60; and overwrites
                         * our own options.
                         *
                         * @param {ReplSet} replset
                         * @ignore
                         */
                        Server.prototype.inheritReplSetOptionsFrom = function (replset) {
                          this.socketOptions = {};
                          this.socketOptions.connectTimeoutMS = replset.options.socketOptions.connectTimeoutMS || 30000;
                        
                          if(replset.options.ssl) {
                            // Set ssl on
                            this.socketOptions.ssl = true;
                            // Set ssl validation
                            this.socketOptions.sslValidate = replset.options.sslValidate == null ? false : replset.options.sslValidate;
                            // Set the ssl certificate authority (array of Buffer/String keys)
                            this.socketOptions.sslCA = Array.isArray(replset.options.sslCA) ? replset.options.sslCA : null;
                            // Set certificate to present
                            this.socketOptions.sslCert = replset.options.sslCert;
                            // Set certificate to present
                            this.socketOptions.sslKey = replset.options.sslKey;
                            // Password to unlock private key
                            this.socketOptions.sslPass = replset.options.sslPass;
                          }
                        
                          // If a socket option object exists clone it
                          if(utils.isObject(replset.options.socketOptions)) {
                            var keys = Object.keys(replset.options.socketOptions);
                            for(var i = 0; i &lt; keys.length; i++)
                              this.socketOptions[keys[i]] = replset.options.socketOptions[keys[i]];
                          }
                        }
                        
                        /**
                         * Opens this server connection.
                         *
                         * @ignore
                         */
                        Server.prototype.connect = function(dbInstance, options, callback) {
                          if(&#x27;function&#x27; === typeof options) callback = options, options = {};
                          if(options == null) options = {};
                          if(!(&#x27;function&#x27; === typeof callback)) callback = null;
                          var self = this;
                          // Save the options
                          this.options = options;
                        
                          // Currently needed to work around problems with multiple connections in a pool with ssl
                          // TODO fix if possible
                          if(this.ssl == true) {
                            // Set up socket options for ssl
                            this.socketOptions.ssl = true;
                            // Set ssl validation
                            this.socketOptions.sslValidate = this.sslValidate == null ? false : this.sslValidate;
                            // Set the ssl certificate authority (array of Buffer/String keys)
                            this.socketOptions.sslCA = Array.isArray(this.sslCA) ? this.sslCA : null;
                            // Set certificate to present
                            this.socketOptions.sslCert = this.sslCert;
                            // Set certificate to present
                            this.socketOptions.sslKey = this.sslKey;
                            // Password to unlock private key
                            this.socketOptions.sslPass = this.sslPass;
                          }
                        
                          // Let&#x27;s connect
                          var server = this;
                          // Let&#x27;s us override the main receiver of events
                          var eventReceiver = options.eventReceiver != null ? options.eventReceiver : this;
                          // Save reference to dbInstance
                          this.db = dbInstance;  // &#x60;db&#x60; property matches ReplSet and Mongos
                          this.dbInstances = [dbInstance];
                        
                          // Force connection pool if there is one
                          if(server.connectionPool) server.connectionPool.stop();
                          // Set server state to connecting
                          this._serverState = &#x27;connecting&#x27;;
                        
                          if(server.connectionPool != null) {
                            // Remove all the listeners on the pool so it does not fire messages all over the place
                            this.connectionPool.removeAllEventListeners();
                            // Close the connection if it&#x27;s open
                            this.connectionPool.stop(true);    
                          }
                        
                          this.connectionPool = new ConnectionPool(this.host, this.port, this.poolSize, dbInstance.bson, this.socketOptions);
                          var connectionPool = this.connectionPool;
                          // If ssl is not enabled don&#x27;t wait between the pool connections
                          if(this.ssl == null || !this.ssl) connectionPool._timeToWait = null;
                          // Set logger on pool
                          connectionPool.logger = this.logger;
                          connectionPool.bson = dbInstance.bson;
                        
                          // Set basic parameters passed in
                          var returnIsMasterResults = options.returnIsMasterResults == null ? false : options.returnIsMasterResults;
                        
                          // Create a default connect handler, overriden when using replicasets
                          var connectCallback = function(_server) {
                            return function(err, reply) {  
                              // ensure no callbacks get called twice
                              var internalCallback = callback;
                              callback = null;
                              
                              // Assign the server
                              _server = _server != null ? _server : server;
                              
                              // If something close down the connection and removed the callback before
                              // proxy killed connection etc, ignore the erorr as close event was isssued
                              if(err != null &amp;&amp; internalCallback == null) return;
                              // Internal callback
                              if(err != null) return internalCallback(err, null, _server);
                              _server.master = reply.documents[0].ismaster == 1 ? true : false;
                              _server.connectionPool.setMaxBsonSize(reply.documents[0].maxBsonObjectSize);
                              _server.connectionPool.setMaxMessageSizeBytes(reply.documents[0].maxMessageSizeBytes);
                              _server.connectionPool.setMaxWriteBatchSize(reply.documents[0].maxWriteBatchSize);
                              // Set server state to connEcted
                              _server._serverState = &#x27;connected&#x27;;
                              // Set server as connected
                              _server.connected = true;
                              // Save document returned so we can query it
                              _server.isMasterDoc = reply.documents[0];
                              
                              if(self.emitOpen) {        
                                _server._emitAcrossAllDbInstances(_server, eventReceiver, &quot;open&quot;, null, returnIsMasterResults ? reply : null, null);        
                                self.emitOpen = false;
                              } else {
                                _server._emitAcrossAllDbInstances(_server, eventReceiver, &quot;reconnect&quot;, null, returnIsMasterResults ? reply : null, null);        
                              }
                        
                              // Set server capabilities
                              server.serverCapabilities = new ServerCapabilities(_server.isMasterDoc);      
                        
                              // If we have it set to returnIsMasterResults
                              if(returnIsMasterResults) {
                                internalCallback(null, reply, _server);
                              } else {
                                internalCallback(null, dbInstance, _server);
                              }
                            }
                          };
                        
                          // Let&#x27;s us override the main connect callback
                          var connectHandler = options.connectHandler == null ? connectCallback(server) : options.connectHandler;
                        
                          // Set up on connect method
                          connectionPool.on(&quot;poolReady&quot;, function() {
                            // Create db command and Add the callback to the list of callbacks by the request id (mapping outgoing messages to correct callbacks)
                            var db_command = DbCommand.NcreateIsMasterCommand(dbInstance, dbInstance.databaseName);
                            // Check out a reader from the pool
                            var connection = connectionPool.checkoutConnection();
                            // Register handler for messages
                            server._registerHandler(db_command, false, connection, connectHandler);
                            // Write the command out
                            connection.write(db_command);
                          })
                        
                          // Set up item connection
                          connectionPool.on(&quot;message&quot;, function(message) {
                            // Attempt to parse the message
                            try {
                              // Create a new mongo reply
                              var mongoReply = new MongoReply()
                              // Parse the header
                              mongoReply.parseHeader(message, connectionPool.bson)
                        
                              // If message size is not the same as the buffer size
                              // something went terribly wrong somewhere
                              if(mongoReply.messageLength != message.length) {
                                // Emit the error
                                if(eventReceiver.listeners(&quot;error&quot;) &amp;&amp; eventReceiver.listeners(&quot;error&quot;).length &gt; 0) eventReceiver.emit(&quot;error&quot;, new Error(&quot;bson length is different from message length&quot;), server);
                                // Remove all listeners
                                server.removeAllListeners();
                              } else {
                                var startDate = new Date().getTime();
                        
                                // Callback instance
                                var callbackInfo = server._findHandler(mongoReply.responseTo.toString());
                                // Abort if not a valid callbackInfo, don&#x27;t try to call it
                                if(callbackInfo == null || callbackInfo.info == null) return;
                        
                                // The command executed another request, log the handler again under that request id
                                if(mongoReply.requestId &gt; 0 &amp;&amp; mongoReply.cursorId.toString() != &quot;0&quot; 
                                  &amp;&amp; callbackInfo &amp;&amp; callbackInfo.info &amp;&amp; callbackInfo.info.exhaust) {
                                    server._reRegisterHandler(mongoReply.requestId, callbackInfo);
                                }
                        
                                // Parse the body
                                mongoReply.parseBody(message, connectionPool.bson, callbackInfo.info.raw, function(err) {
                                  if(err != null) {
                                    // If pool connection is already closed
                                    if(server._serverState === &#x27;disconnected&#x27;) return;
                                    // Set server state to disconnected
                                    server._serverState = &#x27;disconnected&#x27;;
                                    // Remove all listeners and close the connection pool
                                    server.removeAllListeners();
                                    connectionPool.stop(true);
                        
                                    // If we have a callback return the error
                                    if(typeof callback === &#x27;function&#x27;) {
                                      // ensure no callbacks get called twice
                                      var internalCallback = callback;
                                      callback = null;
                                      // Perform callback
                                      internalCallback(err, null, server);
                                    } else if(server.isSetMember()) {
                                      if(server.listeners(&quot;parseError&quot;) &amp;&amp; server.listeners(&quot;parseError&quot;).length &gt; 0) server.emit(&quot;parseError&quot;, utils.toError(err), server);
                                    } else {
                                      if(eventReceiver.listeners(&quot;parseError&quot;) &amp;&amp; eventReceiver.listeners(&quot;parseError&quot;).length &gt; 0) eventReceiver.emit(&quot;parseError&quot;, utils.toError(err), server);
                                    }
                        
                                    // If we are a single server connection fire errors correctly
                                    if(!server.isSetMember()) {
                                      // Fire all callback errors
                                      server.__executeAllCallbacksWithError(err);
                                      // Emit error
                                      server._emitAcrossAllDbInstances(server, eventReceiver, &quot;parseError&quot;, server, null, true);
                                    }
                                    // Short cut
                                    return;
                                  }
                        
                                  // Let&#x27;s record the stats info if it&#x27;s enabled
                                  if(server.recordQueryStats == true &amp;&amp; server._state[&#x27;runtimeStats&#x27;] != null
                                    &amp;&amp; server._state.runtimeStats[&#x27;queryStats&#x27;] instanceof RunningStats) {
                                    // Add data point to the running statistics object
                                    server._state.runtimeStats.queryStats.push(new Date().getTime() - callbackInfo.info.start);
                                  }
                        
                                  // Dispatch the call
                                  server._callHandler(mongoReply.responseTo, mongoReply, null);
                        
                                  // If we have an error about the server not being master or primary
                                  if((mongoReply.responseFlag &amp; (1 &lt;&lt; 1)) != 0
                                    &amp;&amp; mongoReply.documents[0].code
                                    &amp;&amp; mongoReply.documents[0].code == 13436) {
                                      server.close();
                                  }
                                });
                              }
                            } catch (err) {
                              // Throw error in next tick
                              processor(function() {
                                throw err;
                              })
                            }
                          });
                        
                          // Handle timeout
                          connectionPool.on(&quot;timeout&quot;, function(err) {
                            // If pool connection is already closed
                            if(server._serverState === &#x27;disconnected&#x27; 
                              || server._serverState === &#x27;destroyed&#x27;) return;
                            // Set server state to disconnected
                            server._serverState = &#x27;disconnected&#x27;;
                            // If we have a callback return the error
                            if(typeof callback === &#x27;function&#x27;) {
                              // ensure no callbacks get called twice
                              var internalCallback = callback;
                              callback = null;
                              // Perform callback
                              internalCallback(err, null, server);
                            } else if(server.isSetMember()) {
                              if(server.listeners(&quot;timeout&quot;) &amp;&amp; server.listeners(&quot;timeout&quot;).length &gt; 0) server.emit(&quot;timeout&quot;, err, server);
                            } else {
                              if(eventReceiver.listeners(&quot;timeout&quot;) &amp;&amp; eventReceiver.listeners(&quot;timeout&quot;).length &gt; 0) eventReceiver.emit(&quot;timeout&quot;, err, server);
                            }
                        
                            // If we are a single server connection fire errors correctly
                            if(!server.isSetMember()) {
                              // Fire all callback errors
                              server.__executeAllCallbacksWithError(err);
                              // Emit error
                              server._emitAcrossAllDbInstances(server, eventReceiver, &quot;timeout&quot;, err, server, true);
                            }
                        
                            // If we have autoConnect enabled let&#x27;s fire up an attempt to reconnect
                            if(server.isAutoReconnect() 
                              &amp;&amp; !server.isSetMember()
                              &amp;&amp; (server._serverState != &#x27;destroyed&#x27;)
                              &amp;&amp; !server._reconnectInProgreess) {
                              // Set the number of retries
                              server._reconnect_retries = server.db.numberOfRetries;
                              // Attempt reconnect
                              server._reconnectInProgreess = true;
                              setTimeout(__attemptReconnect(server), server.db.retryMiliSeconds);
                            }    
                          });
                        
                          // Handle errors
                          connectionPool.on(&quot;error&quot;, function(message, connection, error_options) {
                            // If pool connection is already closed
                            if(server._serverState === &#x27;disconnected&#x27; 
                              || server._serverState === &#x27;destroyed&#x27;) return;
                            
                            // Set server state to disconnected
                            server._serverState = &#x27;disconnected&#x27;;
                            // Error message
                            var error_message = new Error(message &amp;&amp; message.err ? message.err : message);
                            // Error message coming from ssl
                            if(error_options &amp;&amp; error_options.ssl) error_message.ssl = true;
                        
                            // If we have a callback return the error
                            if(typeof callback === &#x27;function&#x27;) {
                              // ensure no callbacks get called twice
                              var internalCallback = callback;
                              callback = null;
                              // Perform callback
                              internalCallback(error_message, null, server);
                            } else if(server.isSetMember()) {
                              if(server.listeners(&quot;error&quot;) &amp;&amp; server.listeners(&quot;error&quot;).length &gt; 0) server.emit(&quot;error&quot;, error_message, server);
                            } else {
                              if(eventReceiver.listeners(&quot;error&quot;) &amp;&amp; eventReceiver.listeners(&quot;error&quot;).length &gt; 0) eventReceiver.emit(&quot;error&quot;, error_message, server);
                            }
                        
                            // If we are a single server connection fire errors correctly
                            if(!server.isSetMember()) {
                              // Fire all callback errors
                              server.__executeAllCallbacksWithError(error_message);
                              // Emit error
                              server._emitAcrossAllDbInstances(server, eventReceiver, &quot;error&quot;, error_message, server, true);
                            }
                        
                            // If we have autoConnect enabled let&#x27;s fire up an attempt to reconnect
                            if(server.isAutoReconnect() 
                              &amp;&amp; !server.isSetMember()
                              &amp;&amp; (server._serverState != &#x27;destroyed&#x27;)
                              &amp;&amp; !server._reconnectInProgreess) {
                        
                              // Set the number of retries
                              server._reconnect_retries = server.db.numberOfRetries;
                              // Attempt reconnect
                              server._reconnectInProgreess = true;
                              setTimeout(__attemptReconnect(server), server.db.retryMiliSeconds);
                            }    
                          });
                        
                          // Handle close events
                          connectionPool.on(&quot;close&quot;, function() {
                            // If pool connection is already closed
                            if(server._serverState === &#x27;disconnected&#x27; 
                              || server._serverState === &#x27;destroyed&#x27;) return;
                            // Set server state to disconnected
                            server._serverState = &#x27;disconnected&#x27;;
                            // If we have a callback return the error
                            if(typeof callback == &#x27;function&#x27;) {
                              // ensure no callbacks get called twice
                              var internalCallback = callback;
                              callback = null;
                              // Perform callback
                              internalCallback(new Error(&quot;connection closed&quot;), null, server);
                            } else if(server.isSetMember()) {
                              if(server.listeners(&quot;close&quot;) &amp;&amp; server.listeners(&quot;close&quot;).length &gt; 0) server.emit(&quot;close&quot;, new Error(&quot;connection closed&quot;), server);
                            } else {
                              if(eventReceiver.listeners(&quot;close&quot;) &amp;&amp; eventReceiver.listeners(&quot;close&quot;).length &gt; 0) eventReceiver.emit(&quot;close&quot;, new Error(&quot;connection closed&quot;), server);
                            }
                        
                            // If we are a single server connection fire errors correctly
                            if(!server.isSetMember()) {
                              // Fire all callback errors
                              server.__executeAllCallbacksWithError(new Error(&quot;connection closed&quot;));
                              // Emit error
                              server._emitAcrossAllDbInstances(server, eventReceiver, &quot;close&quot;, server, null, true);
                            }
                        
                            // If we have autoConnect enabled let&#x27;s fire up an attempt to reconnect
                            if(server.isAutoReconnect() 
                              &amp;&amp; !server.isSetMember()
                              &amp;&amp; (server._serverState != &#x27;destroyed&#x27;)
                              &amp;&amp; !server._reconnectInProgreess) {
                        
                              // Set the number of retries
                              server._reconnect_retries = server.db.numberOfRetries;  
                              // Attempt reconnect
                              server._reconnectInProgreess = true;
                              setTimeout(__attemptReconnect(server), server.db.retryMiliSeconds);
                            }    
                          });
                        
                          /**
                           * @ignore
                           */
                          var __attemptReconnect = function(server) {
                            return function() {
                              // Attempt reconnect
                              server.connect(server.db, server.options, function(err, result) {
                                server._reconnect_retries = server._reconnect_retries - 1;
                        
                                if(err) {
                                  // Retry
                                  if(server._reconnect_retries == 0 || server._serverState == &#x27;destroyed&#x27;) {
                                    server._serverState = &#x27;connected&#x27;;
                                    server._reconnectInProgreess = false
                                    // Fire all callback errors
                                    return server.__executeAllCallbacksWithError(new Error(&quot;failed to reconnect to server&quot;));
                                  } else {
                                    return setTimeout(__attemptReconnect(server), server.db.retryMiliSeconds);
                                  }
                                } else {
                                  // Set as authenticating (isConnected will be false)
                                  server._serverState = &#x27;authenticating&#x27;;
                                  // Apply any auths, we don&#x27;t try to catch any errors here
                                  // as there are nowhere to simply propagate them to
                                  self._apply_auths(server.db, function(err, result) {            
                                    server._serverState = &#x27;connected&#x27;;
                                    server._reconnectInProgreess = false;
                        
                                    // Execute any buffered reads and writes
                                    server._commandsStore.execute_queries();
                                    server._commandsStore.execute_writes();
                                    // Emit reconnect event
                                    server.emit(&#x27;reconnect&#x27;);
                                  });
                                } 
                              });      
                            }
                          }
                        
                          // If we have a parser error we are in an unknown state, close everything and emit
                          // error
                          connectionPool.on(&quot;parseError&quot;, function(err) {
                            // If pool connection is already closed
                            if(server._serverState === &#x27;disconnected&#x27; 
                              || server._serverState === &#x27;destroyed&#x27;) return;
                            // Set server state to disconnected
                            server._serverState = &#x27;disconnected&#x27;;
                            // If we have a callback return the error
                            if(typeof callback === &#x27;function&#x27;) {
                              // ensure no callbacks get called twice
                              var internalCallback = callback;
                              callback = null;
                              // Perform callback
                              internalCallback(utils.toError(err), null, server);
                            } else if(server.isSetMember()) {
                              if(server.listeners(&quot;parseError&quot;) &amp;&amp; server.listeners(&quot;parseError&quot;).length &gt; 0) server.emit(&quot;parseError&quot;, utils.toError(err), server);
                            } else {
                              if(eventReceiver.listeners(&quot;parseError&quot;) &amp;&amp; eventReceiver.listeners(&quot;parseError&quot;).length &gt; 0) eventReceiver.emit(&quot;parseError&quot;, utils.toError(err), server);
                            }
                        
                            // If we are a single server connection fire errors correctly
                            if(!server.isSetMember()) {
                              // Fire all callback errors
                              server.__executeAllCallbacksWithError(utils.toError(err));
                              // Emit error
                              server._emitAcrossAllDbInstances(server, eventReceiver, &quot;parseError&quot;, server, null, true);
                              // Emit close event
                              if(eventReceiver.listeners(&quot;close&quot;) &amp;&amp; eventReceiver.listeners(&quot;close&quot;).length &gt; 0) eventReceiver.emit(&quot;close&quot;, new Error(&quot;connection closed&quot;), server); }
                          });
                        
                          // Boot up connection poole, pass in a locator of callbacks
                          connectionPool.start();
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype.allRawConnections = function() {
                          return this.connectionPool != null ? this.connectionPool.getAllConnections() : [];
                        }
                        
                        /**
                         * Check if a writer can be provided
                         * @ignore
                         */
                        var canCheckoutWriter = function(self, read) {
                          // We cannot write to an arbiter or secondary server
                          if(self.isMasterDoc &amp;&amp; self.isMasterDoc[&#x27;arbiterOnly&#x27;] == true) {
                            return new Error(&quot;Cannot write to an arbiter&quot;);
                          } if(self.isMasterDoc &amp;&amp; self.isMasterDoc[&#x27;secondary&#x27;] == true) {
                            return new Error(&quot;Cannot write to a secondary&quot;);
                          } else if(read == true &amp;&amp; self._readPreference == ReadPreference.SECONDARY &amp;&amp; self.isMasterDoc &amp;&amp; self.isMasterDoc[&#x27;ismaster&#x27;] == true) {
                            return new Error(&quot;Cannot read from primary when secondary only specified&quot;);
                          } else if(!self.isMasterDoc) {
                            return new Error(&quot;Cannot determine state of server&quot;);
                          }
                        
                          // Return no error
                          return null;
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype.checkoutWriter = function(read) {
                          if(this._serverState == &#x27;disconnected&#x27; || this._serverState == &#x27;destroyed&#x27;)
                            return null;
                          if(read == true) return this.connectionPool.checkoutConnection();
                          // Check if are allowed to do a checkout (if we try to use an arbiter f.ex)
                          var result = canCheckoutWriter(this, read);
                          // If the result is null check out a writer
                          if(result == null &amp;&amp; this.connectionPool != null) {
                            var connection = this.connectionPool.checkoutConnection();
                            // Add server capabilities to the connection
                            if(connection)
                              connection.serverCapabilities = this.serverCapabilities;
                            return connection;
                          } else if(result == null) {
                            return null;
                          } else {
                            return result;
                          }
                        }
                        
                        /**
                         * Check if a reader can be provided
                         * @ignore
                         */
                        var canCheckoutReader = function(self) {
                          // We cannot write to an arbiter or secondary server
                          if(self.isMasterDoc &amp;&amp; self.isMasterDoc[&#x27;arbiterOnly&#x27;] == true &amp;&amp; self.isSetMember()) {
                            return new Error(&quot;Cannot write to an arbiter&quot;);
                          } else if(self._readPreference != null) {
                            // If the read preference is Primary and the instance is not a master return an error
                            if((self._readPreference == ReadPreference.PRIMARY) &amp;&amp; self.isMasterDoc &amp;&amp; self.isMasterDoc[&#x27;ismaster&#x27;] != true) {
                              return new Error(&quot;Read preference is Server.PRIMARY and server is not master&quot;);
                            } else if(self._readPreference == ReadPreference.SECONDARY &amp;&amp; self.isMasterDoc &amp;&amp; self.isMasterDoc[&#x27;ismaster&#x27;] == true) {
                              return new Error(&quot;Cannot read from primary when secondary only specified&quot;);
                            }
                          } else if(!self.isMasterDoc) {
                            return new Error(&quot;Cannot determine state of server&quot;);
                          }
                        
                          // Return no error
                          return null;
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype.checkoutReader = function(read) {
                          if(this._serverState == &#x27;disconnected&#x27; || this._serverState == &#x27;destroyed&#x27;)
                            return null;
                          // Check if are allowed to do a checkout (if we try to use an arbiter f.ex)
                          var result = canCheckoutReader(this);
                          // If the result is null check out a writer
                          if(result == null &amp;&amp; this.connectionPool != null) {
                            var connection = this.connectionPool.checkoutConnection();
                            // Add server capabilities to the connection
                            if(connection)
                              connection.serverCapabilities = this.serverCapabilities;
                            return connection;
                          } else if(result == null) {
                            return null;
                          } else {
                            return result;
                          }
                        }
                        
                        /**
                         * @ignore
                         */
                        Server.prototype.enableRecordQueryStats = function(enable) {
                          this.recordQueryStats = enable;
                        }
                        
                        /**
                         * Internal statistics object used for calculating average and standard devitation on
                         * running queries
                         * @ignore
                         */
                        var RunningStats = function() {
                          var self = this;
                          this.m_n = 0;
                          this.m_oldM = 0.0;
                          this.m_oldS = 0.0;
                          this.m_newM = 0.0;
                          this.m_newS = 0.0;
                        
                          // Define getters
                          Object.defineProperty(this, &quot;numDataValues&quot;, { enumerable: true
                            , get: function () { return this.m_n; }
                          });
                        
                          Object.defineProperty(this, &quot;mean&quot;, { enumerable: true
                            , get: function () { return (this.m_n &gt; 0) ? this.m_newM : 0.0; }
                          });
                        
                          Object.defineProperty(this, &quot;variance&quot;, { enumerable: true
                            , get: function () { return ((this.m_n &gt; 1) ? this.m_newS/(this.m_n - 1) : 0.0); }
                          });
                        
                          Object.defineProperty(this, &quot;standardDeviation&quot;, { enumerable: true
                            , get: function () { return Math.sqrt(this.variance); }
                          });
                        
                          Object.defineProperty(this, &quot;sScore&quot;, { enumerable: true
                            , get: function () {
                              var bottom = this.mean + this.standardDeviation;
                              if(bottom == 0) return 0;
                              return ((2 * this.mean * this.standardDeviation)/(bottom));
                            }
                          });
                        }
                        
                        /**
                         * @ignore
                         */
                        RunningStats.prototype.push = function(x) {
                          // Update the number of samples
                          this.m_n = this.m_n + 1;
                          
                          // See Knuth TAOCP vol 2, 3rd edition, page 232
                          if(this.m_n == 1) {
                            this.m_oldM = this.m_newM = x;
                            this.m_oldS = 0.0;
                          } else {
                            this.m_newM = this.m_oldM + (x - this.m_oldM) / this.m_n;
                            this.m_newS = this.m_oldS + (x - this.m_oldM) * (x - this.m_newM);
                            // set up for next iteration
                            this.m_oldM = this.m_newM;
                            this.m_oldS = this.m_newS;
                          }
                        }
                        
                        /**
                         * @ignore
                         */
                        Object.defineProperty(Server.prototype, &quot;autoReconnect&quot;, { enumerable: true
                          , get: function () {
                              return this.options[&#x27;auto_reconnect&#x27;] == null ? false : this.options[&#x27;auto_reconnect&#x27;];
                            }
                        });
                        
                        /**
                         * @ignore
                         */
                        Object.defineProperty(Server.prototype, &quot;connection&quot;, { enumerable: true
                          , get: function () {
                              return this.internalConnection;
                            }
                          , set: function(connection) {
                              this.internalConnection = connection;
                            }
                        });
                        
                        /**
                         * @ignore
                         */
                        Object.defineProperty(Server.prototype, &quot;master&quot;, { enumerable: true
                          , get: function () {
                              return this.internalMaster;
                            }
                          , set: function(value) {
                              this.internalMaster = value;
                            }
                        });
                        
                        /**
                         * @ignore
                         */
                        Object.defineProperty(Server.prototype, &quot;primary&quot;, { enumerable: true
                          , get: function () {
                              return this;
                            }
                        });
                        
                        /**
                         * Getter for query Stats
                         * @ignore
                         */
                        Object.defineProperty(Server.prototype, &quot;queryStats&quot;, { enumerable: true
                          , get: function () {
                              return this._state.runtimeStats.queryStats;
                            }
                        });
                        
                        /**
                         * @ignore
                         */
                        Object.defineProperty(Server.prototype, &quot;runtimeStats&quot;, { enumerable: true
                          , get: function () {
                              return this._state.runtimeStats;
                            }
                        });
                        
                        /**
                         * Get Read Preference method
                         * @ignore
                         */
                        Object.defineProperty(Server.prototype, &quot;readPreference&quot;, { enumerable: true
                          , get: function () {
                              if(this._readPreference == null &amp;&amp; this.readSecondary) {
                                return Server.READ_SECONDARY;
                              } else if(this._readPreference == null &amp;&amp; !this.readSecondary) {
                                return Server.READ_PRIMARY;
                              } else {
                                return this._readPreference;
                              }
                            }
                        });
                        
                        /**
                         * @ignore
                         */
                        exports.Server = Server;
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
