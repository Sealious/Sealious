<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bin/node_modules/mongodb/lib/mongodb/connection/repl_set/repl_set.js - Prometheus Framework</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Prometheus Framework"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Represents a 
                Replicaset Configuration.html">Represents a 
                Replicaset Configuration</a></li>
                                <li><a href="../classes/Represents a BatchWriteResult.html">Represents a BatchWriteResult</a></li>
                                <li><a href="../classes/Represents a Collection.html">Represents a Collection</a></li>
                                <li><a href="../classes/Represents a Cursor..html">Represents a Cursor.</a></li>
                                <li><a href="../classes/Represents a CursorStream..html">Represents a CursorStream.</a></li>
                                <li><a href="../classes/Represents a Db.html">Represents a Db</a></li>
                                <li><a href="../classes/Represents a GridFS File Stream..html">Represents a GridFS File Stream.</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Represents a MongoClient.html">Represents a MongoClient</a></li>
                                <li><a href="../classes/Represents a Mongos connection with failover to backup proxies.html">Represents a Mongos connection with failover to backup proxies</a></li>
                                <li><a href="../classes/Represents a OrderedBulkOperation.html">Represents a OrderedBulkOperation</a></li>
                                <li><a href="../classes/Represents a Read Preference..html">Represents a Read Preference.</a></li>
                                <li><a href="../classes/Represents a Server connection..html">Represents a Server connection.</a></li>
                                <li><a href="../classes/Represents a UnorderedBulkOperation.html">Represents a UnorderedBulkOperation</a></li>
                                <li><a href="../classes/Represents the Admin methods of MongoDB..html">Represents the Admin methods of MongoDB.</a></li>
                                <li><a href="../classes/Represents the Grid..html">Represents the Grid.</a></li>
                                <li><a href="../classes/Represents the GridStore..html">Represents the GridStore.</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/association.html">association</a></li>
                                <li><a href="../modules/database-accessor.html">database-accessor</a></li>
                                <li><a href="../modules/field-type-manager.html">field-type-manager</a></li>
                                <li><a href="../modules/resource-type-manager.html">resource-type-manager</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: bin/node_modules/mongodb/lib/mongodb/connection/repl_set/repl_set.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        var ReadPreference = require(&#x27;../read_preference&#x27;).ReadPreference
                          , DbCommand = require(&#x27;../../commands/db_command&#x27;).DbCommand
                          , inherits = require(&#x27;util&#x27;).inherits
                          , format = require(&#x27;util&#x27;).format
                          , timers = require(&#x27;timers&#x27;)
                          , Server = require(&#x27;../server&#x27;).Server
                          , utils = require(&#x27;../../utils&#x27;)
                          , PingStrategy = require(&#x27;./strategies/ping_strategy&#x27;).PingStrategy
                          , StatisticsStrategy = require(&#x27;./strategies/statistics_strategy&#x27;).StatisticsStrategy
                          , Options = require(&#x27;./options&#x27;).Options
                          , ReplSetState = require(&#x27;./repl_set_state&#x27;).ReplSetState
                          , HighAvailabilityProcess = require(&#x27;./ha&#x27;).HighAvailabilityProcess
                          , Base = require(&#x27;../base&#x27;).Base;
                        
                        var STATE_STARTING_PHASE_1 = 0;
                        var STATE_PRIMARY = 1;
                        var STATE_SECONDARY = 2;
                        var STATE_RECOVERING = 3;
                        var STATE_FATAL_ERROR = 4;
                        var STATE_STARTING_PHASE_2 = 5;
                        var STATE_UNKNOWN = 6;
                        var STATE_ARBITER = 7;
                        var STATE_DOWN = 8;
                        var STATE_ROLLBACK = 9;
                        
                        // Set processor, setImmediate if 0.10 otherwise nextTick
                        var processor = require(&#x27;../../utils&#x27;).processor();
                        
                        /**
                         * ReplSet constructor provides replicaset functionality
                         *
                         * Options
                         *  - **ha** {Boolean, default:true}, turn on high availability.
                         *  - **haInterval** {Number, default:2000}, time between each replicaset status check.
                         *  - **reconnectWait** {Number, default:1000}, time to wait in miliseconds before attempting reconnect.
                         *  - **retries** {Number, default:30}, number of times to attempt a replicaset reconnect.
                         *  - **rs_name** {String}, the name of the replicaset to connect to.
                         *  - **socketOptions** {Object, default:null}, an object containing socket options to use (noDelay:(boolean), keepAlive:(number), connectTimeoutMS:(number), socketTimeoutMS:(number))
                         *  - **strategy** {String, default:&#x27;ping&#x27;}, selection strategy for reads choose between (ping, statistical and none, default is ping)
                         *  - **secondaryAcceptableLatencyMS** {Number, default:15}, sets the range of servers to pick when using NEAREST (lowest ping ms + the latency fence, ex: range of 1 to (1 + 15) ms)
                         *  - **connectWithNoPrimary** {Boolean, default:false}, sets if the driver should connect even if no primary is available
                         *  - **connectArbiter** {Boolean, default:false}, sets if the driver should connect to arbiters or not.
                         *  - **logger** {Object, default:null}, an object representing a logger that you want to use, needs to support functions debug, log, error **({error:function(message, object) {}, log:function(message, object) {}, debug:function(message, object) {}})**.
                         *  - **poolSize** {Number, default:5}, number of connections in the connection pool for each server instance, set to 5 as default for legacy reasons.
                         *  - **ssl** {Boolean, default:false}, use ssl connection (needs to have a mongod server with ssl support)
                         *  - **sslValidate** {Boolean, default:false}, validate mongod server certificate against ca (needs to have a mongod server with ssl support, 2.4 or higher)
                         *  - **sslCA** {Array, default:null}, Array of valid certificates either as Buffers or Strings (needs to have a mongod server with ssl support, 2.4 or higher)
                         *  - **sslCert** {Buffer/String, default:null}, String or buffer containing the certificate we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
                         *  - **sslKey** {Buffer/String, default:null}, String or buffer containing the certificate private key we wish to present (needs to have a mongod server with ssl support, 2.4 or higher)
                         *  - **sslPass** {Buffer/String, default:null}, String or buffer containing the certificate password (needs to have a mongod server with ssl support, 2.4 or higher)
                         *
                         * @class Represents a 
                         Replicaset Configuration
                         * @param {Array} list of server objects participating in the replicaset.
                         * @param {Object} [options] additional options for the replicaset connection.
                         */
                        var ReplSet = exports.ReplSet = function(servers, options) {
                          // Set up basic
                          if(!(this instanceof ReplSet))
                            return new ReplSet(servers, options);
                        
                          // Set up event emitter
                          Base.call(this);
                        
                          // Ensure we have a list of servers
                          if(!Array.isArray(servers)) throw Error(&quot;The parameter must be an array of servers and contain at least one server&quot;);
                          // Ensure no Mongos&#x27;s
                          for(var i = 0; i &lt; servers.length; i++) {
                            if(!(servers[i] instanceof Server)) throw new Error(&quot;list of servers must be of type Server&quot;);
                          }
                        
                          // Save the options
                          this.options = new Options(options);
                          // Ensure basic validation of options
                          this.options.init();
                        
                          // Server state
                          this._serverState = ReplSet.REPLSET_DISCONNECTED;
                          // Add high availability process
                          this._haProcess = new HighAvailabilityProcess(this, this.options);
                        
                          // Let&#x27;s iterate over all the provided server objects and decorate them
                          this.servers = this.options.decorateAndClean(servers, this._callBackStore);
                          // Throw error if no seed servers
                          if(this.servers.length == 0) throw new Error(&quot;No valid seed servers in the array&quot;);
                        
                          // Let&#x27;s set up our strategy object for picking secondaries
                          if(this.options.strategy == &#x27;ping&#x27;) {
                            // Create a new instance
                            this.strategyInstance = new PingStrategy(this, this.options.secondaryAcceptableLatencyMS);
                          } else if(this.options.strategy == &#x27;statistical&#x27;) {
                            // Set strategy as statistical
                            this.strategyInstance = new StatisticsStrategy(this);
                            // Add enable query information
                            this.enableRecordQueryStats(true);
                          }
                        
                          this.emitOpen = this.options.emitOpen || true;
                          // Set up a clean state
                          this._state = new ReplSetState(this);
                          // Current round robin selected server
                          this._currentServerChoice = 0;
                          // Ensure up the server callbacks
                          for(var i = 0; i &lt; this.servers.length; i++) {
                            this.servers[i]._callBackStore = this._callBackStore;
                            this.servers[i].name = format(&quot;%s:%s&quot;, this.servers[i].host, this.servers[i].port)
                            this.servers[i].replicasetInstance = this;
                            this.servers[i].options.auto_reconnect = false;
                            this.servers[i].inheritReplSetOptionsFrom(this);
                          }
                        
                          // Allow setting the socketTimeoutMS on all connections
                          // to work around issues such as secondaries blocking due to compaction
                          utils.setSocketTimeoutProperty(this, this.options.socketOptions);
                        }
                        
                        /**
                         * @ignore
                         */
                        inherits(ReplSet, Base);
                        
                        // Replicaset states
                        ReplSet.REPLSET_CONNECTING = &#x27;connecting&#x27;;
                        ReplSet.REPLSET_DISCONNECTED = &#x27;disconnected&#x27;;
                        ReplSet.REPLSET_CONNECTED = &#x27;connected&#x27;;
                        ReplSet.REPLSET_RECONNECTING = &#x27;reconnecting&#x27;;
                        ReplSet.REPLSET_DESTROYED = &#x27;destroyed&#x27;;
                        ReplSet.REPLSET_READ_ONLY = &#x27;readonly&#x27;;
                        
                        ReplSet.prototype.isAutoReconnect = function() {
                          return true;
                        }
                        
                        ReplSet.prototype.canWrite = function() {
                          return this._state.master &amp;&amp; this._state.master.isConnected();
                        }
                        
                        ReplSet.prototype.canRead = function(read) {
                          if((read == ReadPreference.PRIMARY 
                              || (typeof read == &#x27;object&#x27; &amp;&amp; read.mode == ReadPreference.PRIMARY)
                              || read == null || read == false) &amp;&amp; (this._state.master == null || !this._state.master.isConnected())) return false;
                          return Object.keys(this._state.secondaries).length &gt; 0;
                        }
                        
                        /**
                         * @ignore
                         */
                        ReplSet.prototype.enableRecordQueryStats = function(enable) {
                          // Set the global enable record query stats
                          this.recordQueryStats = enable;
                        
                          // Enable all the servers
                          for(var i = 0; i &lt; this.servers.length; i++) {
                            this.servers[i].enableRecordQueryStats(enable);
                          }
                        }
                        
                        /**
                         * @ignore
                         */
                        ReplSet.prototype.setSocketOptions = function(options) {
                          var servers = this.allServerInstances();
                          
                          if(typeof options.socketTimeoutMS == &#x27;number&#x27;) {
                            this.options.socketOptions.socketTimeoutMS = options.socketTimeoutMS;
                          }
                        
                          if(typeof options.connectTimeoutMS == &#x27;number&#x27;)
                            this.options.socketOptions.connectTimeoutMS = options.connectTimeoutMS;
                        
                          for(var i = 0; i &lt; servers.length; i++) {
                            servers[i].setSocketOptions(options);
                          }
                        }
                        
                        /**
                         * @ignore
                         */
                        ReplSet.prototype.setReadPreference = function(preference) {
                          this.options.readPreference = preference;
                        }
                        
                        ReplSet.prototype.connect = function(parent, options, callback) {
                          if(this._serverState != ReplSet.REPLSET_DISCONNECTED) 
                            return callback(new Error(&quot;in process of connection&quot;));
                        
                          // If no callback throw
                          if(!(typeof callback == &#x27;function&#x27;)) 
                            throw new Error(&quot;cannot call ReplSet.prototype.connect with no callback function&quot;);
                        
                          var self = this;
                          // Save db reference
                          this.options.db = parent;
                          // Set replicaset as connecting
                          this._serverState = ReplSet.REPLSET_CONNECTING
                          // Copy all the servers to our list of seeds
                          var candidateServers = this.servers.slice(0);
                          // Pop the first server
                          var server = candidateServers.pop();
                          server.name = format(&quot;%s:%s&quot;, server.host, server.port);
                          // Set up the options
                          var opts = {
                            returnIsMasterResults: true,
                            eventReceiver: server
                          }
                        
                          // Register some event listeners
                          this.once(&quot;fullsetup&quot;, function(err, db, replset) {
                            // Set state to connected
                            self._serverState = ReplSet.REPLSET_CONNECTED;
                            // Stop any process running
                            if(self._haProcess) self._haProcess.stop();
                            // Start the HA process
                            self._haProcess.start();
                        
                            // Emit fullsetup
                            processor(function() {
                              if(self.emitOpen)
                                self._emitAcrossAllDbInstances(self, null, &quot;open&quot;, null, null, null);        
                        
                              self._emitAcrossAllDbInstances(self, null, &quot;fullsetup&quot;, null, null, null);        
                            });
                        
                            // If we have a strategy defined start it
                            if(self.strategyInstance) {
                              self.strategyInstance.start();
                            }
                        
                            // Finishing up the call
                            callback(err, db, replset);
                          });
                        
                          // Errors
                          this.once(&quot;connectionError&quot;, function(err, result) {
                            callback(err, result);
                          });
                        
                          // Attempt to connect to the server
                          server.connect(this.options.db, opts, _connectHandler(this, candidateServers, server));
                        }
                        
                        ReplSet.prototype.close = function(callback) {  
                          var self = this;
                          // Set as destroyed
                          this._serverState = ReplSet.REPLSET_DESTROYED;
                          // Stop the ha
                          this._haProcess.stop();
                          
                          // If we have a strategy stop it
                          if(this.strategyInstance) {
                            this.strategyInstance.stop();
                          }
                        
                          // Kill all servers available
                          for(var name in this._state.addresses) {
                            this._state.addresses[name].close();
                          }
                        
                          // Clean out the state
                          this._state = new ReplSetState(this); 
                          
                          // Emit close event
                          processor(function() {
                            self._emitAcrossAllDbInstances(self, null, &quot;close&quot;, null, null, true)    
                          });
                        
                          // Flush out any remaining call handlers
                          self._flushAllCallHandlers(utils.toError(&quot;Connection Closed By Application&quot;));
                        
                          // Callback
                          if(typeof callback == &#x27;function&#x27;) 
                            return callback(null, null);
                        }
                        
                        /**
                         * Creates a new server for the &#x60;replset&#x60; based on &#x60;host&#x60;.
                         *
                         * @param {String} host - host:port pair (localhost:27017)
                         * @param {ReplSet} replset - the ReplSet instance
                         * @return {Server}
                         * @ignore
                         */
                        var createServer = function(self, host, options) {
                          // copy existing socket options to new server
                          var socketOptions = {}
                          if(options.socketOptions) {
                            var keys = Object.keys(options.socketOptions);
                            for(var k = 0; k &lt; keys.length; k++) {
                              socketOptions[keys[k]] = options.socketOptions[keys[k]];
                            }
                          }
                        
                          var parts = host.split(/:/);
                          if(1 === parts.length) {
                            parts[1] = Connection.DEFAULT_PORT;
                          }
                        
                          socketOptions.host = parts[0];
                          socketOptions.port = parseInt(parts[1], 10);
                        
                          var serverOptions = {
                            readPreference: options.readPreference,
                            socketOptions: socketOptions,
                            poolSize: options.poolSize,
                            logger: options.logger,
                            auto_reconnect: false,
                            ssl: options.ssl,
                            sslValidate: options.sslValidate,
                            sslCA: options.sslCA,
                            sslCert: options.sslCert,
                            sslKey: options.sslKey,
                            sslPass: options.sslPass
                          }
                        
                          var server = new Server(socketOptions.host, socketOptions.port, serverOptions);
                          // Set up shared state
                          server._callBackStore = self._callBackStore;
                          server.replicasetInstance = self;
                          server.enableRecordQueryStats(self.recordQueryStats);
                          // Set up event handlers
                          server.on(&quot;close&quot;, _handler(&quot;close&quot;, self, server));
                          server.on(&quot;error&quot;, _handler(&quot;error&quot;, self, server));
                          server.on(&quot;timeout&quot;, _handler(&quot;timeout&quot;, self, server));
                          return server;
                        }
                        
                        var _handler = function(event, self, server) {
                          return function(err, doc) {
                            // The event happened to a primary
                            // Remove it from play
                            if(self._state.isPrimary(server)) {    
                              // Emit that the primary left the replicaset
                              self.emit(&#x27;left&#x27;, &#x27;primary&#x27;, server);
                              // Get the current master
                              var current_master = self._state.master;
                              self._state.master = null;
                              self._serverState = ReplSet.REPLSET_READ_ONLY;
                            
                              if(current_master != null) {
                                // Unpack variables
                                var host = current_master.socketOptions.host;
                                var port = current_master.socketOptions.port;
                        
                                // Fire error on any unknown callbacks
                                self.__executeAllServerSpecificErrorCallbacks(host, port, err);        
                              }
                            } else if(self._state.isSecondary(server)) {
                              // Emit that a secondary left the replicaset
                              self.emit(&#x27;left&#x27;, &#x27;secondary&#x27;, server);
                              // Delete from the list
                              delete self._state.secondaries[server.name];
                            }
                        
                            // If there is no more connections left and the setting is not destroyed
                            // set to disconnected
                            if(Object.keys(self._state.addresses).length == 0 
                              &amp;&amp; self._serverState != ReplSet.REPLSET_DESTROYED) {
                                self._serverState = ReplSet.REPLSET_DISCONNECTED;
                        
                                // Emit close across all the attached db instances
                                self._dbStore.emit(&quot;close&quot;, new Error(&quot;replicaset disconnected, no valid servers contactable over tcp&quot;), null, true);
                            }
                        
                            // Unpack variables
                            var host = server.socketOptions.host;
                            var port = server.socketOptions.port;
                        
                            // Fire error on any unknown callbacks
                            self.__executeAllServerSpecificErrorCallbacks(host, port, err);
                          }
                        }
                        
                        var locateNewServers = function(self, state, candidateServers, ismaster) {
                          // Retrieve the host
                          var hosts = ismaster.hosts;
                          // In candidate servers
                          var inCandidateServers = function(name, candidateServers) {
                            for(var i = 0; i &lt; candidateServers.length; i++) {
                              if(candidateServers[i].name == name) return true;
                            }
                        
                            return false;
                          }
                        
                          // New servers
                          var newServers = [];
                          if(Array.isArray(hosts)) {
                            // Let&#x27;s go over all the hosts
                            for(var i = 0; i &lt; hosts.length; i++) {
                              if(!state.contains(hosts[i]) 
                                &amp;&amp; !inCandidateServers(hosts[i], candidateServers)) {
                                  newServers.push(createServer(self, hosts[i], self.options));
                              }
                            }    
                          }
                        
                          // Return list of possible new servers
                          return newServers;
                        }
                        
                        var _connectHandler = function(self, candidateServers, instanceServer) {
                          return function(err, doc) {
                            // If we have an error add to the list
                            if(err) {
                              self._state.errors[instanceServer.name] = instanceServer;
                            } else {
                              delete self._state.errors[instanceServer.name];
                            }
                        
                            if(!err) {      
                              var ismaster = doc.documents[0]
                        
                              // Error the server if 
                              if(!ismaster.ismaster
                                &amp;&amp; !ismaster.secondary) {
                                self._state.errors[instanceServer.name] = instanceServer;
                              }
                            }
                        
                        
                            // No error let&#x27;s analyse the ismaster command
                            if(!err &amp;&amp; self._state.errors[instanceServer.name] == null) {
                              var ismaster = doc.documents[0]
                        
                              // If no replicaset name exists set the current one
                              if(self.options.rs_name == null) {
                                self.options.rs_name = ismaster.setName;
                              }
                        
                              // If we have a member that is not part of the set let&#x27;s finish up
                              if(typeof ismaster.setName == &#x27;string&#x27; &amp;&amp; ismaster.setName != self.options.rs_name) {
                                return self.emit(&quot;connectionError&quot;, new Error(&quot;Replicaset name &quot; + ismaster.setName + &quot; does not match specified name &quot; + self.options.rs_name));
                              }
                        
                              // Add the error handlers
                              instanceServer.on(&quot;close&quot;, _handler(&quot;close&quot;, self, instanceServer));
                              instanceServer.on(&quot;error&quot;, _handler(&quot;error&quot;, self, instanceServer));
                              instanceServer.on(&quot;timeout&quot;, _handler(&quot;timeout&quot;, self, instanceServer));
                              
                              // Set any tags on the instance server
                              instanceServer.name = ismaster.me;
                              instanceServer.tags = ismaster.tags;
                        
                              // Add the server to the list
                              self._state.addServer(instanceServer, ismaster);
                        
                              // Check if we have more servers to add (only check when done with initial set)
                              if(candidateServers.length == 0) {
                                // Get additional new servers that are not currently in set
                                var new_servers = locateNewServers(self, self._state, candidateServers, ismaster);
                        
                                // Locate any new servers that have not errored out yet
                                for(var i = 0; i &lt; new_servers.length; i++) {
                                  if(self._state.errors[new_servers[i].name] == null) {
                                    candidateServers.push(new_servers[i])            
                                  }
                                }
                              }
                            }
                        
                            // If the candidate server list is empty and no valid servers
                            if(candidateServers.length == 0 &amp;&amp;
                              !self._state.hasValidServers()) {
                                return self.emit(&quot;connectionError&quot;, new Error(&quot;No valid replicaset instance servers found&quot;));
                            } else if(candidateServers.length == 0) {      
                              if(!self.options.connectWithNoPrimary &amp;&amp; (self._state.master == null || !self._state.master.isConnected())) {
                                return self.emit(&quot;connectionError&quot;, new Error(&quot;No primary found in set&quot;));
                              }
                              return self.emit(&quot;fullsetup&quot;, null, self.options.db, self);
                            }
                                
                            // Let&#x27;s connect the next server    
                            var nextServer = candidateServers.pop();
                          
                            // Set up the options
                            var opts = {
                              returnIsMasterResults: true,
                              eventReceiver: nextServer
                            }
                        
                            // Attempt to connect to the server
                            nextServer.connect(self.options.db, opts, _connectHandler(self, candidateServers, nextServer));
                          }
                        }
                        
                        ReplSet.prototype.isDestroyed = function() {
                          return this._serverState == ReplSet.REPLSET_DESTROYED;
                        }
                        
                        ReplSet.prototype.isConnected = function(read) {
                          var isConnected = false;  
                        
                          if(read == null || read == ReadPreference.PRIMARY || read == false)
                            isConnected = this._state.master != null &amp;&amp; this._state.master.isConnected();
                        
                          if((read == ReadPreference.PRIMARY_PREFERRED || read == ReadPreference.SECONDARY_PREFERRED || read == ReadPreference.NEAREST)
                            &amp;&amp; ((this._state.master != null &amp;&amp; this._state.master.isConnected())
                            || (this._state &amp;&amp; this._state.secondaries &amp;&amp; Object.keys(this._state.secondaries).length &gt; 0))) {
                              isConnected = true;
                          } else if(read == ReadPreference.SECONDARY) {
                            isConnected = this._state &amp;&amp; this._state.secondaries &amp;&amp; Object.keys(this._state.secondaries).length &gt; 0;
                          }
                        
                          // No valid connection return false
                          return isConnected;
                        }
                        
                        ReplSet.prototype.isMongos = function() {
                          return false;
                        }
                        
                        ReplSet.prototype.checkoutWriter = function() {
                          if(this._state.master) return this._state.master.checkoutWriter();
                          return new Error(&quot;no writer connection available&quot;);
                        }
                        
                        ReplSet.prototype.processIsMaster = function(_server, _ismaster) {
                          // Server in recovery mode, remove it from available servers
                          if(!_ismaster.ismaster &amp;&amp; !_ismaster.secondary) {
                            // Locate the actual server
                            var server = this._state.addresses[_server.name];
                            // Close the server, simulating the closing of the connection
                            // to get right removal semantics
                            if(server) server.close();
                            // Execute any callback errors
                            _handler(null, this, server)(new Error(&quot;server is in recovery mode&quot;));
                          }
                        }
                        
                        ReplSet.prototype.allRawConnections = function() {
                          var connections = [];
                        
                          for(var name in this._state.addresses) {
                            connections = connections.concat(this._state.addresses[name].allRawConnections());
                          }
                        
                          return connections;
                        }
                        
                        /**
                         * @ignore
                         */
                        ReplSet.prototype.allServerInstances = function() {
                          var self = this;
                          // If no state yet return empty
                          if(!self._state) return [];
                          // Close all the servers (concatenate entire list of servers first for ease)
                          var allServers = self._state.master != null ? [self._state.master] : [];
                        
                          // Secondary keys
                          var keys = Object.keys(self._state.secondaries);
                          // Add all secondaries
                          for(var i = 0; i &lt; keys.length; i++) {
                            allServers.push(self._state.secondaries[keys[i]]);
                          }
                        
                          // Return complete list of all servers
                          return allServers;
                        }
                        
                        /**
                         * @ignore
                         */
                        ReplSet.prototype.checkoutReader = function(readPreference, tags) {
                          var connection = null;
                        
                          // If we have a read preference object unpack it
                          if(typeof readPreference == &#x27;object&#x27; &amp;&amp; readPreference[&#x27;_type&#x27;] == &#x27;ReadPreference&#x27;) {
                            // Validate if the object is using a valid mode
                            if(!readPreference.isValid()) throw new Error(&quot;Illegal readPreference mode specified, &quot; + JSON.stringify(readPreference.mode));
                            // Set the tag
                            tags = readPreference.tags;
                            readPreference = readPreference.mode;
                          } else if(typeof readPreference == &#x27;object&#x27; &amp;&amp; readPreference[&#x27;_type&#x27;] != &#x27;ReadPreference&#x27;) {
                            return new Error(&quot;read preferences must be either a string or an instance of ReadPreference&quot;);
                          }
                        
                          // Set up our read Preference, allowing us to override the readPreference
                          var finalReadPreference = readPreference != null ? readPreference : this.options.readPreference;
                        
                          // Ensure we unpack a reference
                          if(finalReadPreference != null &amp;&amp; typeof finalReadPreference == &#x27;object&#x27; &amp;&amp; finalReadPreference[&#x27;_type&#x27;] == &#x27;ReadPreference&#x27;) {
                            // Validate if the object is using a valid mode
                            if(!finalReadPreference.isValid()) throw new Error(&quot;Illegal readPreference mode specified, &quot; + JSON.stringify(finalReadPreference.mode));
                            // Set the tag
                            tags = finalReadPreference.tags;
                            readPreference = finalReadPreference.mode;
                          }
                        
                          // Finalize the read preference setup
                          finalReadPreference = finalReadPreference == true ? ReadPreference.SECONDARY_PREFERRED : finalReadPreference;
                          finalReadPreference = finalReadPreference == null ? ReadPreference.PRIMARY : finalReadPreference;
                        
                          // If we are reading from a primary
                          if(finalReadPreference == &#x27;primary&#x27;) {
                            // If we provide a tags set send an error
                            if(typeof tags == &#x27;object&#x27; &amp;&amp; tags != null) {
                              return new Error(&quot;PRIMARY cannot be combined with tags&quot;);
                            }
                        
                            // If we provide a tags set send an error
                            if(this._state.master == null) {
                              return new Error(&quot;No replica set primary available for query with ReadPreference PRIMARY&quot;);
                            }
                        
                            // Checkout a writer
                            return this.checkoutWriter();
                          }
                        
                          // If we have specified to read from a secondary server grab a random one and read
                          // from it, otherwise just pass the primary connection
                          if((this.options.readSecondary || finalReadPreference == ReadPreference.SECONDARY_PREFERRED || finalReadPreference == ReadPreference.SECONDARY) &amp;&amp; Object.keys(this._state.secondaries).length &gt; 0) {
                            // If we have tags, look for servers matching the specific tag
                            if(this.strategyInstance != null) {
                              // Only pick from secondaries
                              var _secondaries = [];
                              for(var key in this._state.secondaries) {
                                _secondaries.push(this._state.secondaries[key]);
                              }
                        
                              if(finalReadPreference == ReadPreference.SECONDARY) {
                                // Check out the nearest from only the secondaries
                                connection = this.strategyInstance.checkoutConnection(tags, _secondaries);
                              } else {
                                connection = this.strategyInstance.checkoutConnection(tags, _secondaries);
                                // No candidate servers that match the tags, error
                                if(connection == null || connection instanceof Error) {
                                  // No secondary server avilable, attemp to checkout a primary server
                                  connection = this.checkoutWriter();
                                  // If no connection return an error
                                  if(connection == null || connection instanceof Error) {
                                    return new Error(&quot;No replica set members available for query&quot;);
                                  }
                                }
                              }
                            } else if(tags != null &amp;&amp; typeof tags == &#x27;object&#x27;) {
                              // Get connection
                              connection = _pickFromTags(this, tags);// = function(self, readPreference, tags) {
                              // No candidate servers that match the tags, error
                              if(connection == null) {
                                return new Error(&quot;No replica set members available for query&quot;);
                              }
                            } else {
                              connection = _roundRobin(this, tags);
                            }
                          } else if(finalReadPreference == ReadPreference.PRIMARY_PREFERRED) {
                            // Check if there is a primary available and return that if possible
                            connection = this.checkoutWriter();
                            // If no connection available checkout a secondary
                            if(connection == null || connection instanceof Error) {
                              // If we have tags, look for servers matching the specific tag
                              if(tags != null &amp;&amp; typeof tags == &#x27;object&#x27;) {
                                // Get connection
                                connection = _pickFromTags(this, tags);// = function(self, readPreference, tags) {
                                // No candidate servers that match the tags, error
                                if(connection == null) {
                                  return new Error(&quot;No replica set members available for query&quot;);
                                }
                              } else {
                                connection = _roundRobin(this, tags);
                              }
                            }
                          } else if(finalReadPreference == ReadPreference.SECONDARY_PREFERRED) {
                            // If we have tags, look for servers matching the specific tag
                            if(this.strategyInstance != null) {
                              connection = this.strategyInstance.checkoutConnection(tags);
                              
                              // No candidate servers that match the tags, error
                              if(connection == null || connection instanceof Error) {
                                // No secondary server avilable, attemp to checkout a primary server
                                connection = this.checkoutWriter();
                                // If no connection return an error
                                if(connection == null || connection instanceof Error) {
                                  var preferenceName = finalReadPreference == ReadPreference.SECONDARY ? &#x27;secondary&#x27; : finalReadPreference;
                                  return new Error(&quot;No replica set member available for query with ReadPreference &quot; + preferenceName + &quot; and tags &quot; + JSON.stringify(tags));
                                }
                              }
                            } else if(tags != null &amp;&amp; typeof tags == &#x27;object&#x27;) {
                              // Get connection
                              connection = _pickFromTags(this, tags);// = function(self, readPreference, tags) {
                              // No candidate servers that match the tags, error
                              if(connection == null) {
                                // No secondary server avilable, attemp to checkout a primary server
                                connection = this.checkoutWriter();
                                // If no connection return an error
                                if(connection == null || connection instanceof Error) {
                                  var preferenceName = finalReadPreference == ReadPreference.SECONDARY ? &#x27;secondary&#x27; : finalReadPreference;
                                  return new Error(&quot;No replica set member available for query with ReadPreference &quot; + preferenceName + &quot; and tags &quot; + JSON.stringify(tags));
                                }
                              }
                            }
                          } else if(finalReadPreference == ReadPreference.NEAREST &amp;&amp; this.strategyInstance != null) {
                            connection = this.strategyInstance.checkoutConnection(tags);
                          } else if(finalReadPreference == ReadPreference.NEAREST &amp;&amp; this.strategyInstance == null) {
                            return new Error(&quot;A strategy for calculating nearness must be enabled such as ping or statistical&quot;);
                          } else if(finalReadPreference == ReadPreference.SECONDARY &amp;&amp; Object.keys(this._state.secondaries).length == 0) {
                            if(tags != null &amp;&amp; typeof tags == &#x27;object&#x27;) {
                              var preferenceName = finalReadPreference == ReadPreference.SECONDARY ? &#x27;secondary&#x27; : finalReadPreference;
                              return new Error(&quot;No replica set member available for query with ReadPreference &quot; + preferenceName + &quot; and tags &quot; + JSON.stringify(tags));
                            } else {
                              return new Error(&quot;No replica set secondary available for query with ReadPreference SECONDARY&quot;);
                            }
                          } else {
                            connection = this.checkoutWriter();
                          }
                        
                          // Return the connection
                          return connection;
                        }
                        
                        /**
                         * @ignore
                         */
                        var _pickFromTags = function(self, tags) {
                          // If we have an array or single tag selection
                          var tagObjects = Array.isArray(tags) ? tags : [tags];
                          // Iterate over all tags until we find a candidate server
                          for(var _i = 0; _i &lt; tagObjects.length; _i++) {
                            // Grab a tag object
                            var tagObject = tagObjects[_i];
                            // Matching keys
                            var matchingKeys = Object.keys(tagObject);
                            // Match all the servers that match the provdided tags
                            var keys = Object.keys(self._state.secondaries);
                            var candidateServers = [];
                        
                            for(var i = 0; i &lt; keys.length; i++) {
                              var server = self._state.secondaries[keys[i]];
                              // If we have tags match
                              if(server.tags != null) {
                                var matching = true;
                                // Ensure we have all the values
                                for(var j = 0; j &lt; matchingKeys.length; j++) {
                                  if(server.tags[matchingKeys[j]] != tagObject[matchingKeys[j]]) {
                                    matching = false;
                                    break;
                                  }
                                }
                        
                                // If we have a match add it to the list of matching servers
                                if(matching) {
                                  candidateServers.push(server);
                                }
                              }
                            }
                        
                            // If we have a candidate server return
                            if(candidateServers.length &gt; 0) {
                              if(self.strategyInstance) return self.strategyInstance.checkoutConnection(tags, candidateServers);
                              // Set instance to return
                              return candidateServers[Math.floor(Math.random() * candidateServers.length)].checkoutReader();
                            }
                          }
                        
                          // No connection found
                          return null;
                        }
                        
                        /**
                         * Pick a secondary using round robin
                         *
                         * @ignore
                         */
                        function _roundRobin (replset, tags) {
                          var keys = Object.keys(replset._state.secondaries);
                          // Update index
                          replset._currentServerChoice = replset._currentServerChoice + 1;
                          // Pick a server
                          var key = keys[replset._currentServerChoice % keys.length];
                        
                          var conn = null != replset._state.secondaries[key]
                            ? replset._state.secondaries[key].checkoutReader()
                            : null;
                        
                          // If connection is null fallback to first available secondary
                          if(null == conn) {
                            conn = pickFirstConnectedSecondary(replset, tags);
                          }
                        
                          return conn;
                        }
                        
                        /**
                         * @ignore
                         */
                        var pickFirstConnectedSecondary = function pickFirstConnectedSecondary(self, tags) {
                          var keys = Object.keys(self._state.secondaries);
                          var connection;
                        
                          // Find first available reader if any
                          for(var i = 0; i &lt; keys.length; i++) {
                            connection = self._state.secondaries[keys[i]].checkoutReader();
                            if(connection) return connection;
                          }
                        
                          // If we still have a null, read from primary if it&#x27;s not secondary only
                          if(self._readPreference == ReadPreference.SECONDARY_PREFERRED) {
                            connection = self._state.master.checkoutReader();
                            if(connection) return connection;
                          }
                        
                          var preferenceName = self._readPreference == ReadPreference.SECONDARY_PREFERRED
                            ? &#x27;secondary&#x27;
                            : self._readPreference;
                        
                          return new Error(&quot;No replica set member available for query with ReadPreference &quot;
                                          + preferenceName + &quot; and tags &quot; + JSON.stringify(tags));
                        }
                        
                        /**
                         * Get list of secondaries
                         * @ignore
                         */
                        Object.defineProperty(ReplSet.prototype, &quot;secondaries&quot;, {enumerable: true
                          , get: function() {
                              return utils.objectToArray(this._state.secondaries);
                            }
                        });
                        
                        /**
                         * Get list of secondaries
                         * @ignore
                         */
                        Object.defineProperty(ReplSet.prototype, &quot;arbiters&quot;, {enumerable: true
                          , get: function() {
                              return utils.objectToArray(this._state.arbiters);
                            }
                        });
                        
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
