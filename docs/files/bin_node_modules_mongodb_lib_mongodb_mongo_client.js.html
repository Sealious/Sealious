<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bin/node_modules/mongodb/lib/mongodb/mongo_client.js - Prometheus Framework</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Prometheus Framework"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Represents a 
                Replicaset Configuration.html">Represents a 
                Replicaset Configuration</a></li>
                                <li><a href="../classes/Represents a BatchWriteResult.html">Represents a BatchWriteResult</a></li>
                                <li><a href="../classes/Represents a Collection.html">Represents a Collection</a></li>
                                <li><a href="../classes/Represents a Cursor..html">Represents a Cursor.</a></li>
                                <li><a href="../classes/Represents a CursorStream..html">Represents a CursorStream.</a></li>
                                <li><a href="../classes/Represents a Db.html">Represents a Db</a></li>
                                <li><a href="../classes/Represents a GridFS File Stream..html">Represents a GridFS File Stream.</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Represents a MongoClient.html">Represents a MongoClient</a></li>
                                <li><a href="../classes/Represents a Mongos connection with failover to backup proxies.html">Represents a Mongos connection with failover to backup proxies</a></li>
                                <li><a href="../classes/Represents a OrderedBulkOperation.html">Represents a OrderedBulkOperation</a></li>
                                <li><a href="../classes/Represents a Read Preference..html">Represents a Read Preference.</a></li>
                                <li><a href="../classes/Represents a Server connection..html">Represents a Server connection.</a></li>
                                <li><a href="../classes/Represents a UnorderedBulkOperation.html">Represents a UnorderedBulkOperation</a></li>
                                <li><a href="../classes/Represents the Admin methods of MongoDB..html">Represents the Admin methods of MongoDB.</a></li>
                                <li><a href="../classes/Represents the Grid..html">Represents the Grid.</a></li>
                                <li><a href="../classes/Represents the GridStore..html">Represents the GridStore.</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/association.html">association</a></li>
                                <li><a href="../modules/database-accessor.html">database-accessor</a></li>
                                <li><a href="../modules/field-type-manager.html">field-type-manager</a></li>
                                <li><a href="../modules/resource-type-manager.html">resource-type-manager</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: bin/node_modules/mongodb/lib/mongodb/mongo_client.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        var Db = require(&#x27;./db&#x27;).Db
                          , Server = require(&#x27;./connection/server&#x27;).Server
                          , Mongos = require(&#x27;./connection/mongos&#x27;).Mongos
                          , ReplSet = require(&#x27;./connection/repl_set/repl_set&#x27;).ReplSet
                          , ReadPreference = require(&#x27;./connection/read_preference&#x27;).ReadPreference
                          , inherits = require(&#x27;util&#x27;).inherits
                          , EventEmitter = require(&#x27;events&#x27;).EventEmitter
                          , parse = require(&#x27;./connection/url_parser&#x27;).parse;
                        
                        /**
                         * Create a new MongoClient instance.
                         *
                         * Options
                         *  - **w**, {Number/String, &gt; -1 || &#x27;majority&#x27; || tag name} the write concern for the operation where &lt; 1 is no acknowlegement of write and w &gt;= 1, w = &#x27;majority&#x27; or tag acknowledges the write
                         *  - **wtimeout**, {Number, 0} set the timeout for waiting for write concern to finish (combines with w option)
                         *  - **fsync**, (Boolean, default:false) write waits for fsync before returning, from MongoDB 2.6 on, fsync cannot be combined with journal
                         *  - **j**, (Boolean, default:false) write waits for journal sync before returning
                         *  - **readPreference** {String}, the prefered read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST).
                         *  - **native_parser** {Boolean, default:false}, use c++ bson parser.
                         *  - **forceServerObjectId** {Boolean, default:false}, force server to create _id fields instead of client.
                         *  - **pkFactory** {Object}, object overriding the basic ObjectID primary key generation.
                         *  - **serializeFunctions** {Boolean, default:false}, serialize functions.
                         *  - **raw** {Boolean, default:false}, peform operations using raw bson buffers.
                         *  - **recordQueryStats** {Boolean, default:false}, record query statistics during execution.
                         *  - **retryMiliSeconds** {Number, default:5000}, number of miliseconds between retries.
                         *  - **numberOfRetries** {Number, default:5}, number of retries off connection.
                         *  - **bufferMaxEntries** {Boolean, default: -1}, sets a cap on how many operations the driver will buffer up before giving up on getting a working connection, default is -1 which is unlimited
                         *
                         * @class Represents a MongoClient
                         * @param {Object} serverConfig server config object.
                         * @param {Object} [options] additional options for the collection.
                         */
                        function MongoClient(serverConfig, options) {
                          if(serverConfig != null) {
                            options = options ? options : {};
                            // If no write concern is set set the default to w:1
                            if(&#x27;w&#x27; in options === false) {
                              options.w = 1;
                            }
                            
                            // The internal db instance we are wrapping
                            this._db = new Db(&#x27;test&#x27;, serverConfig, options);    
                          }
                        }
                        
                        /**
                         * @ignore
                         */
                        inherits(MongoClient, EventEmitter);
                        
                        /**
                         * Connect to MongoDB using a url as documented at
                         *
                         *  docs.mongodb.org/manual/reference/connection-string/
                         *
                         * Options
                         *  - **uri_decode_auth** {Boolean, default:false} uri decode the user name and password for authentication
                         *  - **db** {Object, default: null} a hash off options to set on the db object, see **Db constructor**
                         *  - **server** {Object, default: null} a hash off options to set on the server objects, see **Server** constructor**
                         *  - **replSet** {Object, default: null} a hash off options to set on the replSet object, see **ReplSet** constructor**
                         *  - **mongos** {Object, default: null} a hash off options to set on the mongos object, see **Mongos** constructor**
                         *
                         * @param {String} url connection url for MongoDB.
                         * @param {Object} [options] optional options for insert command
                         * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the initialized db object or null if an error occured.
                         * @return {null}
                         * @api public
                         */
                        MongoClient.prototype.connect = function(url, options, callback) {
                          var self = this;
                        
                          if(typeof options == &#x27;function&#x27;) {
                            callback = options;
                            options = {};
                          }
                        
                          MongoClient.connect(url, options, function(err, db) {
                            if(err) return callback(err, db);
                            // Store internal db instance reference
                            self._db = db;
                            // Emit open and perform callback
                            self.emit(&quot;open&quot;, err, db);
                            callback(err, db);
                          });
                        }
                        
                        /**
                         * Initialize the database connection.
                         *
                         * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the connected mongoclient or null if an error occured.
                         * @return {null}
                         * @api public
                         */
                        MongoClient.prototype.open = function(callback) {
                          // Self reference
                          var self = this;
                          // Open the db
                          this._db.open(function(err, db) {
                            if(err) return callback(err, null);
                            // Emit open event
                            self.emit(&quot;open&quot;, err, db);
                            // Callback
                            callback(null, self);
                          })
                        }
                        
                        /**
                         * Close the current db connection, including all the child db instances. Emits close event and calls optional callback.
                         *
                         * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the results from the close method or null if an error occured.
                         * @return {null}
                         * @api public
                         */
                        MongoClient.prototype.close = function(callback) {
                          this._db.close(callback);
                        }
                        
                        /**
                         * Create a new Db instance sharing the current socket connections.
                         *
                         * @param {String} dbName the name of the database we want to use.
                         * @return {Db} a db instance using the new database.
                         * @api public
                         */
                        MongoClient.prototype.db = function(dbName) {
                          return this._db.db(dbName);
                        }
                        
                        /**
                         * Connect to MongoDB using a url as documented at
                         *
                         *  docs.mongodb.org/manual/reference/connection-string/
                         *
                         * Options
                         *  - **uri_decode_auth** {Boolean, default:false} uri decode the user name and password for authentication
                         *  - **db** {Object, default: null} a hash off options to set on the db object, see **Db constructor**
                         *  - **server** {Object, default: null} a hash off options to set on the server objects, see **Server** constructor**
                         *  - **replSet** {Object, default: null} a hash off options to set on the replSet object, see **ReplSet** constructor**
                         *  - **mongos** {Object, default: null} a hash off options to set on the mongos object, see **Mongos** constructor**
                         *
                         * @param {String} url connection url for MongoDB.
                         * @param {Object} [options] optional options for insert command
                         * @param {Function} callback this will be called after executing this method. The first parameter will contain the Error object if an error occured, or null otherwise. While the second parameter will contain the initialized db object or null if an error occured.
                         * @return {null}
                         * @api public
                         */
                        MongoClient.connect = function(url, options, callback) {
                          var args = Array.prototype.slice.call(arguments, 1);
                          callback = typeof args[args.length - 1] == &#x27;function&#x27; ? args.pop() : null;
                          options = args.length ? args.shift() : null;
                          options = options || {};
                        
                          // Set default empty server options  
                          var serverOptions = options.server || {};
                          var mongosOptions = options.mongos || {};
                          var replSetServersOptions = options.replSet || options.replSetServers || {};
                          var dbOptions = options.db || {};
                        
                          // If callback is null throw an exception
                          if(callback == null) 
                            throw new Error(&quot;no callback function provided&quot;);
                        
                          // Parse the string
                          var object = parse(url, options);
                        
                          // Merge in any options for db in options object
                          if(dbOptions) {
                            for(var name in dbOptions) object.db_options[name] = dbOptions[name];
                          }
                        
                          // Added the url to the options
                          object.db_options.url = url;
                        
                          // Merge in any options for server in options object
                          if(serverOptions) {
                            for(var name in serverOptions) object.server_options[name] = serverOptions[name];
                          }
                        
                          // Merge in any replicaset server options
                          if(replSetServersOptions) {
                            for(var name in replSetServersOptions) object.rs_options[name] = replSetServersOptions[name];    
                          }
                        
                          // Merge in any replicaset server options
                          if(mongosOptions) {
                            for(var name in mongosOptions) object.mongos_options[name] = mongosOptions[name];    
                          }
                        
                          // We need to ensure that the list of servers are only either direct members or mongos
                          // they cannot be a mix of monogs and mongod&#x27;s
                          var totalNumberOfServers = object.servers.length;
                          var totalNumberOfMongosServers = 0;
                          var totalNumberOfMongodServers = 0;
                          var serverConfig = null;
                          var errorServers = {};
                        
                          // Failure modes
                          if(object.servers.length == 0) throw new Error(&quot;connection string must contain at least one seed host&quot;);
                        
                          // If we have no db setting for the native parser try to set the c++ one first
                          object.db_options.native_parser = _setNativeParser(object.db_options);
                          // If no auto_reconnect is set, set it to true as default for single servers
                          if(typeof object.server_options.auto_reconnect != &#x27;boolean&#x27;) {
                            object.server_options.auto_reconnect = true;
                          }
                        
                          // Establish the correct socketTimeout
                          var connectTimeoutMS = 30000;
                          var socketTimeoutMS = 0;
                        
                          // We have a server connection timeout setting
                          if(object.server_options &amp;&amp; object.server_options.socketOptions &amp;&amp; object.server_options.socketOptions.connectTimeoutMS) {
                            connectTimeoutMS = object.server_options.socketOptions.connectTimeoutMS;
                          }
                        
                          // We have a rs options set for connection timeout, override any server ones
                          if(object.rs_options &amp;&amp; object.rs_options.socketOptions &amp;&amp; object.rs_options.socketOptions.connectTimeoutMS) {
                            connectTimeoutMS = object.rs_options.socketOptions.connectTimeoutMS;
                          }
                        
                          // If we have no socket settings set the default values
                          if(object.rs_options.socketOptions.connectTimeoutMS == null) {
                            object.rs_options.socketOptions.connectTimeoutMS = connectTimeoutMS;
                          }
                        
                          if(object.rs_options.socketOptions.socketTimeoutMS == null) {
                            object.rs_options.socketOptions.socketTimeoutMS = socketTimeoutMS;
                          }
                        
                          if(object.server_options.socketOptions.connectTimeoutMS == null) {
                            object.server_options.socketOptions.connectTimeoutMS = connectTimeoutMS;
                          }
                        
                          if(object.server_options.socketOptions.socketTimeoutMS == null) {
                            object.server_options.socketOptions.socketTimeoutMS = socketTimeoutMS;
                          }
                        
                          // If we have more than a server, it could be replicaset or mongos list
                          // need to verify that it&#x27;s one or the other and fail if it&#x27;s a mix
                          // Connect to all servers and run ismaster
                          for(var i = 0; i &lt; object.servers.length; i++) {
                            // Set up socket options
                            var _server_options = {
                                poolSize:1
                              , socketOptions: {
                                  connectTimeoutMS: connectTimeoutMS 
                                , socketTimeoutMS: socketTimeoutMS
                              }
                              , auto_reconnect:false};
                        
                            // Ensure we have ssl setup for the servers
                            if(object.rs_options.ssl) {
                              _server_options.ssl = object.rs_options.ssl;
                              _server_options.sslValidate = object.rs_options.sslValidate;
                              _server_options.sslCA = object.rs_options.sslCA;
                              _server_options.sslCert = object.rs_options.sslCert;
                              _server_options.sslKey = object.rs_options.sslKey;
                              _server_options.sslPass = object.rs_options.sslPass;
                            } else if(object.server_options.ssl) {
                              _server_options.ssl = object.server_options.ssl;
                              _server_options.sslValidate = object.server_options.sslValidate;
                              _server_options.sslCA = object.server_options.sslCA;
                              _server_options.sslCert = object.server_options.sslCert;
                              _server_options.sslKey = object.server_options.sslKey;
                              _server_options.sslPass = object.server_options.sslPass;
                            }
                        
                            // Set up the Server object
                            var _server = object.servers[i].domain_socket 
                                ? new Server(object.servers[i].domain_socket, _server_options)
                                : new Server(object.servers[i].host, object.servers[i].port, _server_options);
                        
                            var connectFunction = function(__server) { 
                              // Attempt connect
                              new Db(object.dbName, __server, {w:1, native_parser:false}).open(function(err, db) {
                                // Update number of servers
                                totalNumberOfServers = totalNumberOfServers - 1;          
                                // If no error do the correct checks
                                if(!err) {
                                  // Close the connection
                                  db.close(true);
                                  var isMasterDoc = db.serverConfig.isMasterDoc;
                                  // Check what type of server we have
                                  if(isMasterDoc.setName) totalNumberOfMongodServers++;
                                  if(isMasterDoc.msg &amp;&amp; isMasterDoc.msg == &quot;isdbgrid&quot;) totalNumberOfMongosServers++;
                                } else {
                                  errorServers[__server.host + &quot;:&quot; + __server.port] = __server;
                                }
                        
                                if(totalNumberOfServers == 0) {
                                  // If we have a mix of mongod and mongos, throw an error
                                  if(totalNumberOfMongosServers &gt; 0 &amp;&amp; totalNumberOfMongodServers &gt; 0) {
                                    return process.nextTick(function() {
                                      try {
                                        callback(new Error(&quot;cannot combine a list of replicaset seeds and mongos seeds&quot;));
                                      } catch (err) {
                                        if(db) db.close();
                                        throw err
                                      }              
                                    })
                                  }
                                  
                                  if(totalNumberOfMongodServers == 0 &amp;&amp; object.servers.length == 1) {
                                    var obj = object.servers[0];
                                    serverConfig = obj.domain_socket ? 
                                        new Server(obj.domain_socket, object.server_options)
                                      : new Server(obj.host, obj.port, object.server_options);            
                                  } else if(totalNumberOfMongodServers &gt; 0 || totalNumberOfMongosServers &gt; 0) {
                                    var finalServers = object.servers
                                      .filter(function(serverObj) {
                                        return errorServers[serverObj.host + &quot;:&quot; + serverObj.port] == null;
                                      })
                                      .map(function(serverObj) {
                                          return new Server(serverObj.host, serverObj.port, object.server_options);
                                      });
                                    // Clean out any error servers
                                    errorServers = {};
                                    // Set up the final configuration
                                    if(totalNumberOfMongodServers &gt; 0) {
                                      serverConfig = new ReplSet(finalServers, object.rs_options);                
                                    } else {
                                      serverConfig = new Mongos(finalServers, object.mongos_options);                         
                                    }
                                  }
                        
                                  if(serverConfig == null) {
                                    return process.nextTick(function() {
                                      try {
                                        callback(new Error(&quot;Could not locate any valid servers in initial seed list&quot;));
                                      } catch (err) {
                                        if(db) db.close();
                                        throw err
                                      }
                                    });
                                  }
                                  // Ensure no firing off open event before we are ready
                                  serverConfig.emitOpen = false;
                                  // Set up all options etc and connect to the database
                                  _finishConnecting(serverConfig, object, options, callback)
                                }
                              });        
                            }
                        
                            // Wrap the context of the call
                            connectFunction(_server);    
                          }    
                        }
                        
                        var _setNativeParser = function(db_options) {
                          if(typeof db_options.native_parser == &#x27;boolean&#x27;) return db_options.native_parser;
                        
                          try {
                            require(&#x27;bson&#x27;).BSONNative.BSON;
                            return true;
                          } catch(err) {
                            return false;
                          }
                        }
                        
                        var _finishConnecting = function(serverConfig, object, options, callback) {
                          // Safe settings
                          var safe = {};
                          // Build the safe parameter if needed
                          if(object.db_options.journal) safe.j = object.db_options.journal;
                          if(object.db_options.w) safe.w = object.db_options.w;
                          if(object.db_options.fsync) safe.fsync = object.db_options.fsync;
                          if(object.db_options.wtimeoutMS) safe.wtimeout = object.db_options.wtimeoutMS;
                        
                          // If we have a read Preference set
                          if(object.db_options.read_preference) {
                            var readPreference = new ReadPreference(object.db_options.read_preference);
                            // If we have the tags set up
                            if(object.db_options.read_preference_tags)
                              readPreference = new ReadPreference(object.db_options.read_preference, object.db_options.read_preference_tags);
                            // Add the read preference
                            object.db_options.readPreference = readPreference;
                          }
                        
                          // No safe mode if no keys
                          if(Object.keys(safe).length == 0) safe = false;
                        
                          // Add the safe object
                          object.db_options.safe = safe;
                        
                          // Get the socketTimeoutMS
                          var socketTimeoutMS = object.server_options.socketOptions.socketTimeoutMS || 0;
                          var connectTimeoutMS = object.server_options.socketOptions.connectTimeoutMS || 30000;
                        
                          // If we have a replset, override with replicaset socket timeout option if available
                          if(serverConfig instanceof ReplSet) {
                            socketTimeoutMS = object.rs_options.socketOptions.socketTimeoutMS || socketTimeoutMS;
                          }
                        
                          //
                          // Set socketTimeout to same as connectionTimeout to ensure we don&#x27;t block on connect and auth
                          // This is a workaround for pre 2.6 servers where auth can hang when indexes are build on secondaries
                          serverConfig.setSocketOptions({socketTimeoutMS: connectTimeoutMS, connectTimeoutMS: connectTimeoutMS});
                        
                          // Set up the db options
                          var db = new Db(object.dbName, serverConfig, object.db_options);
                          // Open the db
                          db.open(function(err, db){
                            if(err) {
                              return process.nextTick(function() {
                                try {
                                  callback(err, null);
                                } catch (err) {
                                  if(db) db.close();
                                  throw err
                                }
                              });
                            }
                        
                            //
                            // Set socketTimeout to same as connectionTimeout to ensure we don&#x27;t block on connect and auth
                            // This is a workaround for pre 2.6 servers where auth can hang when indexes are build on secondaries
                            serverConfig.setSocketOptions({socketTimeoutMS: connectTimeoutMS, connectTimeoutMS: connectTimeoutMS});
                        
                            // Set the provided write concern or fall back to w:1 as default
                            if(db.options !== null &amp;&amp; !db.options.safe &amp;&amp; !db.options.journal 
                              &amp;&amp; !db.options.w &amp;&amp; !db.options.fsync &amp;&amp; typeof db.options.w != &#x27;number&#x27;
                              &amp;&amp; (db.options.safe == false &amp;&amp; object.db_options.url.indexOf(&quot;safe=&quot;) == -1)) {
                                db.options.w = 1;
                            }
                        
                            if(err == null &amp;&amp; object.auth){
                              // What db to authenticate against
                              var authentication_db = db;
                              if(object.db_options &amp;&amp; object.db_options.authSource) {
                                authentication_db = db.db(object.db_options.authSource);
                              }
                        
                              // Build options object
                              var options = {};
                              if(object.db_options.authMechanism) options.authMechanism = object.db_options.authMechanism;
                              if(object.db_options.gssapiServiceName) options.gssapiServiceName = object.db_options.gssapiServiceName;
                        
                              // Authenticate
                              authentication_db.authenticate(object.auth.user, object.auth.password, options, function(err, success){
                                // Reset the socket timeout
                                serverConfig.setSocketOptions({socketTimeoutMS: socketTimeoutMS, connectTimeoutMS: connectTimeoutMS});
                        
                                // Handle the results
                                if(success){
                                  process.nextTick(function() {
                                    try {
                                      callback(null, db);            
                                    } catch (err) {
                                      if(db) db.close();
                                      throw err
                                    }
                                  });
                                } else {
                                  if(db) db.close();
                                  process.nextTick(function() {
                                    try {
                                      callback(err ? err : new Error(&#x27;Could not authenticate user &#x27; + object.auth[0]), null);
                                    } catch (err) {
                                      if(db) db.close();
                                      throw err
                                    }
                                  });
                                }
                              });
                            } else {      
                              // Reset the socket timeout
                              serverConfig.setSocketOptions({socketTimeoutMS: socketTimeoutMS, connectTimeoutMS: connectTimeoutMS});
                        
                              // Return connection      
                              process.nextTick(function() {
                                try {
                                  callback(err, db);            
                                } catch (err) {
                                  if(db) db.close();
                                  throw err
                                }
                              })
                            }
                          });
                        }
                        
                        exports.MongoClient = MongoClient;
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
